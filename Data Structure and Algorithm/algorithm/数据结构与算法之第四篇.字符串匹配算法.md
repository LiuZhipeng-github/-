# 数据结构与算法之第四篇.字符串匹配算法

编程语言提供的字符串查找函数，比如Python 中的 find() 函数等，它们底层就是依赖接下来要讲的字符串匹配算法。

BF 算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是 O(n*m)，n、m 表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。

RK 算法是借助哈希算法对 BF 算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，RK 算法的时间复杂度是 O(n)，跟 BF 算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 O(n*m)。

# 一、BF 算法

BF （Brute Force）算法，中文叫作暴力匹配算法，也叫朴素匹配算法。这种算法的字符串匹配方式很“暴力”，比较简单、好懂，但相应的性能也不高。

**主串**和**模式串**的概念:比如在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。

设主串的长度为n，模式串的长度为m，因为在主串中查找模式串，所以 n>m。

BF 算法的思想就是，穷举主串中起始位置分别是 0、1、2…、n-m 且长度为 m 的 n-m+1 个子串，看有没有跟长度为m的模式串匹配的：

![1570498286430](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/1570498286430.png)

BF 算法每次都比对 m 个字符，最坏情况下要比对 n-m+1 次，所以最坏情况时间复杂度是 O(n*m)。

BF 算法虽然相对其他字符串匹配算法，时间复杂度高，但却是一个最常用的字符串匹配算法，因为大部分情况下，模式串和主串的长度都不会太长。另外BF算法思想简单，代码实现简单不容易出错，即使有 bug 也容易暴露和修复。

在工程中，在满足性能要求的前提下，简单是首选。这也是[KISS（Keep it Simple and Stupid）设计原则](https://zh.wikipedia.org/wiki/KISS原则)。

所以，绝大部分情况下，BF 朴素的字符串匹配算法就够用了。

python实现代码：

```python
def bf(main, pattern) -> int:
    """bf暴搜
    :param main: 主串
    :param pattern: 模式串
    :return:
    """
    n = len(main)
    m = len(pattern)

    if n <= m:
        return 0 if pattern == main else -1

    for i in range(n - m + 1):
        for j in range(m):
            if main[i + j] != pattern[j]: break
            if j == m - 1: return i
    return -1
```



# 二、RK 算法

RK(Rabin-Karp) 算法由它的两位发明者 Rabin 和 Karp 的名字来命名。它算是BF算法的升级版。

RK 算法的思路：

先通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就再对比一下子串和模式串本身。如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的。

因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。

![1570498355108](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/1570498355108.png)

哈希算法的设计的非常有技巧，假设要处理的字符串只包含 K 个字符，可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。

比如要处理的字符串只包含 a～z 这 26 个小写字母，那就用二十六进制来表示一个字符串，把 a～z 这 26 个字符映射到 0～25 这 26 个数字中：
$$
\begin{aligned}
'cba'&='c'*26*26+'b'*26+'a'*1 \\
 &=2*26*26+1*26+0*1 \\
 &=1353
\end{aligned}
$$
![1570498417310](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/1570498417310.png)

相邻两个子串 s[i-1] 和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，可以使用 s[i-1] 的哈希值计算出 s[i] 的哈希值：

![1570498447098](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/1570498447098.png)

$26^{m-1}$ 这部分的计算可以通过查表的方法来提高效率，事先计算好 $26^0、26^1、26^2、\dots、26^{m-1}$，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。当需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。

![1570498470428](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/1570498470428.png)

整个 RK 算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。

计算子串哈希值可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 O(n)。

模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 O(n)。

RK 算法整体的时间复杂度就是 O(n)。

如果模式串很长，上面的哈希算法计算得到的哈希值可能超过计算机中整型数据的表示范围，这时就必须允许哈希冲突。

哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)。

可以将每一个字母从小到大对应一个素数，然后将这些素数求和作为哈希值，这样数据范围就会相对上面的方法小很多，哈希冲突的概率也比较小。

简易python实现：

```python
def simple_hash(s, start, end):
    ret = 0
    for i in range(start, end + 1):
        ret += ord(s[i])
    return ret


def rk(main, pattern):
    """rk搜索算法
    :param main: 主串
    :param pattern: 模式串
    :return:
    """
    n = len(main)
    m = len(pattern)

    if n <= m:
        return 0 if pattern == main else -1

    # 子串哈希值表
    h = [0] * (n - m + 1)
    h[0] = simple_hash(main, 0, m - 1)
    for i in range(1, n - m + 1):
        h[i] = h[i - 1] - ord(main[i - 1]) + ord(main[i + m - 1])
    # 模式串哈希值
    hash_p = simple_hash(pattern, 0, m - 1)

    for i, h in enumerate(h):
        # 可能存在哈希冲突
        if h == hash_p:
            if pattern == main[i:i + m]:
                return i
    return -1
```

# 三、BM 算法

我一直认为KMP算法是最好的字符串匹配算法，直到后来我遇到了BM算法。BM算法的执行效率要比KMP算法**快3-5倍**左右，并且十分容易理解。各种记事本的“查找”功能（CTRL + F）一般都是采用的此算法。
我们拿这个算法的发明人Moore教授的例子来讲解：
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/43520513282_f075ab1143_b.jpg)
首先，原字符串和子串左端对齐，但是从尾部开始比较，就是首先比较“S”和“E”，这是一个十分巧妙的做法，如果字符串不匹配的话，只需要这一次比较就可以确定。
在BM算法中，当每次发现当前字符不匹配的时候，我们就需要寻找一下子串中是否有这个字符；比如当前“S”和“E”不匹配，那我们需要寻找一下子串当中是否存在“S”。发现子串当中并不存在，那我们将子串整体向后移动到原字符串中“S”的下一个位置（但是如果子串中存在原字符串当前字符肿么办呢，我们后面再说）：
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/43520513012_cf6358cf3a_b.jpg)
我们接着从尾部开始比较，发现“P”和“E”不匹配，那我们查找一下子串当中是否存在“P”，发现存在，那我们就把子串移动到两个“P”对齐的位置：
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/43520512792_2076cf0b3d_b.jpg)
已然从尾部开始比较，“E”匹配，“L”匹配，“P”匹配，“M”匹配，“I”和“A”不匹配！那我们就接着寻找一下子串当前是否出现了原字符串中的字符，我们发现子串中第一个“E”和原字符串中的字符可以对应，那直接将子串移动到两个“E”对应的位置：
![这里写图片描述](https://farm1.staticflickr.com/854/43520512542_8882d17e78_b.jpg)
接着从尾部比较，发现“P”和“E”不匹配，那么检查一下子串当中是否出现了“P”，发现存在，那么移动子串到两个“P”对应：
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/43520512252_c392bc8657_b.jpg)
从尾部开始，逐个匹配，发现全部能匹配上，匹配成功~
时间复杂度：最差情况O（MN），最好情况O（N）

BM算法的python完整版代码实现:

```python
from typing import List


def bm(main: str, pattern: str) -> int:
    n, m = len(main), len(pattern)

    if n <= m:
        return 0 if main == pattern else -1

    # bc为坏字符位置表
    bc = generate_bc(pattern)
    # suffix为好后缀匹配的{u*}位置表,prefix为前缀匹配表
    suffix, prefix = generate_gs(pattern)

    i = 0  # i表示在主串中的角标
    while i <= n - m:
        j = m - 1  # j表示在模式串中的角标
        while j >= 0 and main[i + j] == pattern[j]:
            j -= 1
        # j此时表示坏字符首次出现的位置
        if j == m - 1:  # 坏字符出现在模式串尾部，使用坏字符规则
            i += j - bc[ord(main[i + j])]
        elif j == -1:  # 已经匹配成功
            return i
        else:  # 尾部是好后缀，使用好后缀规则
            k = m - 1 - j  # 好后缀的长度
            if suffix[k] != -1:  # 整个好后缀在pattern剩余字符中仍有出现
                i += j - suffix[k] + 1
            else:
                r = k
                while r > 0 and not prefix[r]:
                    r -= 1
                i += m - r
    return -1


def generate_bc(pattern) -> List[int]:
    """生成坏字符位置表"""
    bc = [-1] * 256
    for i, c in enumerate(pattern):
        bc[ord(c)] = i
    return bc


def generate_gs(pattern) -> (List[int], List[bool]):
    m = len(pattern)
    suffix = [-1] * m
    prefix = [False] * m
    for i in range(m - 1):
        k = 1  # pattern[:i+1]和pattern的公共后缀长度
        j = i
        while j >= 0 and pattern[j] == pattern[m - k]:
            suffix[k] = j
            k += 1
            j -= 1
        if j == -1: prefix[k - 1] = True
    return suffix, prefix
```



# 四、KMP算法

**K**nuth-**M**orris-**P**ratt 字符串查找算法，简称为 **KMP算法**，用于在一个主串S内查找一个模式串P的出现位置。这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法。KMP 算法的核心思想是在模式串和主串匹配的过程中，每当遇到坏字符后，对于已经比对过的好前缀，根据某种规律将模式串一次性滑动很多位。

## 4.1 基本原理

在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作**坏字符**，把已经匹配的那段字符串叫作**好前缀**。

![1570499479897](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/1570499479897.png)

在好前缀本身的所有后缀子串中，查找最长的可以跟好前缀的前缀子串匹配的。假设最长的可匹配的前缀子串是{v}，长度是 k。每次遇到坏字符的时候就把 j 更新为 k，i 不变，然后继续比较。相当于把模式串一次性往后滑动 j-k 位。

![1570499526476](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/1570499526476.png)

在***模式串***中***前缀*** 指除了最后一个字符以外，一个字符串的全部头部组合；***后缀*** 指除了第一个字符以外，一个字符串的全部尾部组合。 

为了表述起来方便，将***模式串***中好前缀的所有后缀子串中，最长的前缀子串匹配的后缀子串，叫作***最长可匹配后缀子串***；对应模式串中的前缀子串，叫作***最长可匹配前缀子串***。

![1570499540559](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/1570499540559.png)

以模式串abaabcac为例，列出模式串 P 的所有子串：

a
ab
aba
abaa
abaab
abaabc
abaabca
abaabcac

求得模式串 P 的每一个子串对应的各个前缀后缀的公共元素的 **最大长度表** :

 ![1572778109574](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/1572778109574.png)

很多教材称next 数组叫**失效函数**（failure function），但每本教材对next函数定义的细节都有差别。

根据**最大长度表** 去求 **next 数组**：**next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1**。

 ![1572782164334](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/1572782164334.png)

操作流程：

- 假设现在主串 M 匹配到 i 位置，模式串 P 匹配到 j 位置

- 如果 j = -1，或者当前字符匹配成功（即 M[i] == P[j] ），都令 i++，j++，继续匹配下一个字符；

- 如果 j != -1，且当前字符匹配失败（即 M[i] != P[j] ），则令 i 不变，j = next[j]。
  匹配失败时，模式串 P相对于主串 M 向右移动了 j - next [j] 位
  
- **换言之，将模式串 P 失配位置的 next 数组的值对应的模式串 P 的索引位置移动到失配处**

  ![D365FC19-48B2-4645-A423-EFC29C581CE4_1_201_a](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/D365FC19-48B2-4645-A423-EFC29C581CE4_1_201_a.jpeg)

假设 next 数组已经计算好了，KMP 算法的python实现代码：

```python
def kmp(main: str, pattern: str):
    """kmp字符串匹配"""
    n, m = len(main), len(pattern)

    if m == 0:
        return 0
    if n <= m:
        return 0 if main == pattern else -1

    # 求解next数组
    next = get_next(pattern)

    i, j = 0, 0
    while i < n and j < m:
        if j == -1 or main[i] == pattern[j]:
            i += 1
            j += 1
        else:  # j!=-1 and main[i]!=pattern[j]
            j = next[j]
    if j == m:
        return i - j
    else:
        return -1
```

## 4.2 next 数组

假设已经求得abaa这一列的**最大公共前后缀**的**长度**为1，在它后面添加一个与前缀匹配的字符即可使最大公共前后缀变长。即下一列添加的字符与当前列的**最大公共前后缀**的**长度**后面的字符一样，则**最大公共前后缀长度**的**长度**加1。但如果下一列添加的字符与当前列的**最大公共前后缀**的**长度**后面的字符不一样，则**最大公共前后缀长度**的**长度**置为0，重新开始判断：

![FAFA2D8C-250E-45C1-A531-8586658D6E28_1_105_c](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/FAFA2D8C-250E-45C1-A531-8586658D6E28_1_105_c.jpeg)



python实现代码：

```python
def get_next(pattern):
    """next数组生成"""
    m = len(pattern)
    next = [-1] * m
    i, j = 0, -1
    while i < m - 1:
        if j == -1 or pattern[i] == pattern[j]:
            i += 1
            j += 1
            next[i] = j
        else:
            j = next[j]
    return next
```



## 4.3 KMP 算法复杂度分析

KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以空间复杂度是 O(m)，m 表示模式串的长度。

KMP 算法包含两部分，第一部分是构建 next 数组，第二部分是借助 next 数组进行匹配。

构建 next 数组，仅一层循环，循环次数跟模式串长度m有关，所以构建 next 数组的时间复杂度是 O(m)。借助 next 数组进行匹配，while循环代码如下：

```python
i, j = 0, 0
while i < n and j < m:
    if j == -1 or main[i] == pattern[j]:
        i += 1
        j += 1
    else:  # j!=-1 and main[i]!=pattern[j]
        j = next[j]
```

i 从 0 循环增长到 n-1，j 的总增长量与 i一致也为n。j = next[j]让 j 的值减少，但总减少量不会超过总增长量n。所以 while 循环的循环次数小于2n，借助 next 数组进行匹配的时间复杂度是 O(n)。

故综合两部分的时间复杂度，KMP 算法的时间复杂度是 O(m+n)。

# 五、Sunday算法：

后来，我又发现了一种比BM算法还要快，而且更容易理解的算法，就是这个Sunday算法：
![这里写图片描述](https://farm2.staticflickr.com/1787/42849532114_f39f919c02_o.png)
首先原字符串和子串左端对齐，发现“T”与“E”不匹配之后，检测原字符串中下一个字符（在这个例子中是“IS”后面的那个空格）是否在子串中出现，如果出现移动子串将两者对齐，如果没有出现则直接将子串移动到下一个位置。这里空格没有在子串中出现，移动子串到空格的下一个位置“A”：
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/42849531984_3cf48145d8_o.png)
发现“A”与“E”不匹配，但是原字符串中下一个字符“E”在子串中出现了，第一个字符和最后一个字符都有出现，那么首先移动子串靠后的字符与原字符串对齐：
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.assets/42849531844_b76f72d2cd_o.png)
发现空格和“E”不匹配，原字符串中下一个字符“空格”也没有在子串中出现，所以直接移动子串到空格的下一个字符“E”：
![这里写图片描述](https://farm2.staticflickr.com/1765/42849531704_c20dc0034b_o.png)
这样从头开始逐个匹配，匹配成功！
时间复杂度：最差情况O（MN），最好情况O（N）

