# 数据结构与算法之第二篇.线性表

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182741669)

## 1、线性表的概念和表抽象数据类型

### 1.1 表的概念和性质

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182743105)

### 1.2 表抽象数据类型

（**读者笔记**：这一节讲了**线性表**的**实现者**和**使用者**需要从各自角度**需要考虑的问题**、**使用者角度**考虑一个**线性表数据结构**应该**提供哪些操作**。**请到书上仔细阅读！**）

#### 线性表的操作

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182743954)

#### 表抽象数据类型

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182747235)

#### 1.3 线性表的实现：基本考虑

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182743321)

## 2、顺序表（数组）的实现

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182742818)

### 2.1 基本实现方式
顺序表的两种基本实现方式：1、使用连续的内存空间 2、使用元素外置的方式，即索引结构
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182747507)

### 2.2 顺序表基本操作的实现




**！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！加入数组内容**




### 2.3 **顺序表及其操作的性质**

各种访问操作，**如果**其执行中**不需要扫描表内容**的**全部**或**一部分**，其**时间复杂度**都是**O(1)**，**需要扫描表内容操作时间复杂度都是O(n)**。
顺序表的实现（实现方式：数组）的总结：
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182745904)

### 2.4 顺序表的结构

#### 两种基本实现方式

（读者笔记：这一小节仅截图“分离式结构”，详细见书上。）
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182746638)

#### 替换元素存储区

**分离式实现**的最大**优点**是带来了一种新的可能：可以在**标识不变**的情况下，**为表对象换一块元素存储区**。也就是说，**表**还是**原来的表**，其**内容\*可以\*不变**，但是**容量改变**了。
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182747542)
如果采用**分离式**技术实现，可以在**不改变对象**的情况下**换一块\**\***更大的元素存储区*，使加入元素操作可以正常完成。操作过程如下：
1）另外**申请一块更大**的**元素存储区**。
2）把**表中已有的元素复制到新存储区**。
3）用**新的元素存储区替换原来的元素存储区**（**改变表对象的元素区链接**）。（这里参见图3.6b，读者补充，）
4）**实际加入新元素**。

#### 后端插入和存储区扩充

动态顺序表后端插入的代价不统一，大多数可以在O(1)时间完成，但也会因为替换存储区而出现高代价。当然，高代价操作的出现很偶然，并将随着表的增大而变得越来越稀疏。另一方面，不间断插入元素是这里最坏的情况，一般情况插入和删除操作交替出现，替换存储区的情况会更稀少。但是无论如何，高代价的操作是可能出现的。

### 2.5 Python的list

#### list的基本实现技术

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182747504)

#### 一些主要操作的性质

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182756516)

#### 几个操作

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182749011)



## 3、 链接表

### 3.1 线性表的基本需要和链接表

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182747862)
（读者笔记：我认为的重点在于**“在前一结点里用链接的方式显式地记录与下一结点之间的关联”**）

### 3.2 链表

**！！！！！！！！！！！！！！！！加入链表内容**



### 3.3 链表类的实现

 **自定义异常**

```
class LinkedListUnderflow(ValueError):
    pass12
```

 **各种链表的实现**
 
**！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！这里加入链表的代码**


#### 3.3.4 循环单链表类

（读者笔记：先抄代码吧~~）

```
class LCList: # 循环单链表类
    def __init__(self):
        self._rear = None

    def is_empty(self):
        return self._rear is None

    def prepend(self, elem): # 前段插入
        p = LNode(elem)
        if self._rear is None:
            p.next = p # 建立一个结点的环
            self._rear = p
        else:
            p.next = self._rear.next
            self._rear.next = p

    def append(self, elem): # 尾端插入
        self.prepend(elem)
        self._rear = self._rear.next

    def pop(self): # 前端弹出
        if self._rear is None:
            raise LinkedListUnderflow("in pop of CLList")
        p = self._rear.next
        if self._rear is p:
            self._rear = None
        else:
            self._rear.next = p.next
        return p.elem

    def printall(self): # 输出表元素
        if self.is_empty():
            return
        p = self._rear.next
        while True:
            print(p.elem)
            if p is self._rear:
                break
            p = p.next123456789101112131415161718192021222324252627282930313233343536373839
```

#### 3.4.5 双链表


```
p.next.prev = p.next
p.next.prev = p.prev12
```

这两个语句**使p所指结点**从表中**退出**，**其余结点保持顺序和链接**。如果要考虑前后可能无结点的情况，只需增加适当的条件判断。
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182757385)

```
class DLNode(LNode): # 双链表结点类
    def __init__(self, elem, prev=None, next_=None):
        LNode.__init__(self, elem, next_)
        self.prev = prev1234
```

```
class DLList(LList1):
    def __init__(self):
        LList1.__init__(self)

    def prepend(self, elem):
        p = DLNode(elem, None, self._head)
        if self._head is None:
            self._rear = p
        else:
            p.next.prev = p
        self._head = p

    def append(self, elem):
        p = DLNode(elem, self._rear, None)
        if self._head is None: #
            self._head = p
        else:
            p.prev.next = p
        self._rear = p

    def pop(self):
        if self._head is None:
            raise LinkedListUnderflow("in pop of DLList")
        e = self._head.elem
        self._head = self._head.next
        if self._head is not None: # _head
            self._head.prev = None
        return e

    def pop_last(self):
        if self._head is None:
            raise LinkedListUnderflow("in pop_last of DLList")
        e = self._rear.elem
        self._rear = self._rear.prev
        if self._rear is None:
            self._head = None #
        else:
            self._rear.next = None
        return e123456789101112131415161718192021222324252627282930313233343536373839
```

##### 3.4.6 循环双链表





#### 3.4.7 不同链表的简单总结

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87.%E5%88%97%E8%A1%A8.assets/SouthEast-20201130182759696)
