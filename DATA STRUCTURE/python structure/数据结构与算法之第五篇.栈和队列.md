## 第5章 栈和队列

### 5.1 概述

栈和队列主要用于在计算过程中**保存临时数据的容器**。

#### 5.1.1 栈、队列和数据使用顺序

栈和队列也是最简单的缓存结构，它们**只支持**数据项的**存储**和**访问**，不支持数据项之间任何关系。
\- 栈：后进先出（Last In First Out，LIFO）
\- 队列：先进先出（First In First Out，FIFO）
应该用**线性表**作为**栈**和**队列**的实现结构。
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.assets/SouthEast-20201130183721354)

#### 5.1.2 应用环境

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.assets/SouthEast-20201130183721500)

### 5.2 栈：概念和实现

栈（stack，也称堆栈）是一种容器，可存入数据元素、访问元素、删除元素等。存入栈中的元素之间相互没有任何具体关系，**只有到来的时间的先后顺序**。在这里没有元素的位置、元素的前后顺序等概念。

**栈**的**基本性质保证**，在**任何时刻**可以**访问、删除**的**元素**都是**在此之前最后存入**的那个**元素**。因此，**栈确定了**一种**默认元素访问顺序** ，访问时**无需其他信息**。

#### 5.2.1 栈抽象数据类型

栈的抽象数据类型描述：
![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.assets/SouthEast-20201130183721458)

##### **栈的线性表实现**

用**线性表**的技术**实现栈**时，操作**只**在**表的一端**进行，**不涉及另一端**，更**不涉及**表的**中间**部分。

对于顺序表，后端插入和删除是O(1)的操作，应该用这一端作为栈顶。
对于连接表，前端插入和删除都是O(1)的操作，应该使用这一端作为栈顶。

顺序表扩大存储需要做一次高代价操作；另外顺序表需要完整的的大块存储区。采用连接技术，在这两个问题上都有优势。链接实现的缺点是更多依赖于解释器的存储管理，每个节点的链接开销，以及链接节点在实际计算机内存中任意散布肯能带来的开销。
#### 5.2.2 栈的顺序表实现

由于操作时，栈不满足需要（如空栈弹出）可以看做参数值错误，采用下面定义：

```
class StackUnderflow(ValueError): # 栈下溢（空栈访问）
    pass12
```

下面是一个栈类的定义，其中用一个list类型的数据属性_elems作为栈元素存储区，把`_elems`的首端作为栈底，尾端作为栈顶：


```
class SStack():             # 基于顺序表技术实现的栈类
    def __init__(self):     # 用list对象_elems存储栈中元素
        self._elems = []    # 所有栈操作都映射到list操作

    def is_empty(self):
        return self._elems == []

    def top(self):
        if self._elems == []:
            raise StackUnderflow("in SStack.top()")
        return self._elems[-1]

    def push(self, elem):
        self._elems.append(elem)

    def pop(self):
        if self._elems == []:
            raise StackUnderflow("in SStack.pop()")
        return self._elems.pop()12345678910111213141516171819
```

#### 5.2.3 栈的链接表实现

```
class LStack():     # 基于链接表技术实现的栈类，用LNode作为结点
    def __init__(self):
        self._top = None

    def is_empty(self):
        return self._top is None

    def top(self):
        if self._top is None:
            raise StackUnderflow("in LStack.top()")
        return self._top.elem

    def push(self, elem):
        slef._top = LNode(elem, self._top)

    def pop(self):
        if self._top is None:
            raise StackUnderflow("in LStack.pop()")
        p = self._top
        self._top = p.next
        return p.elem123456789101112131415161718192021
```



#### 5.3.1 简单应用：括号匹配问题

（读者：请看书上的分析）
（读者：继续抄代码。。）

```
def check_parens(text):
    """括号配对检查函数，text是被检查的正文率"""
    parens = "()[]{}"
    open_parens = "([{"
    opposite = {")":"(", "]":"[", "}":"{"} # 表示配对关系的字典

    def parentheses(text):
        """括号生成器，每次调用返回text里的下一括号及其位置"""
        i, text_len = 0, len(text)
        while True:
            while i < text_len and text[i] not in parens:
                i += 1
            if i >= text_len:
                return
            yield text[i], i
            i += 1

        st = SStack() # 保存括号的栈

    for pr, i in parentheses(text): # 对text里各括号和位置迭代
        if pr in open_parens: # 对text里各括号和位置迭代
            st.push(pr)
        elif st.pop() != opposite[pr]: # 不匹配就是失败，退出
            print("Unmatching is found at", i, "for", pr)
            return False
        # else: 这是一次括号配对成功，什么也不做，继续
    print("ALL parentheses are correctly matched.")
    return True     12345678910111213141516171819202122232425262728
```

#### 5.3.2 表达式的表示、计算和变换

（读者：我认为这一小节讲的是栈的应用的一个实例，暂时跳过。）

##### **表达式和计算的描述**

##### **后缀表达式的计算**

##### **中缀表达式到后缀表达式的转换**

##### **中缀表达式的求值**

#### 5.3.3 栈与递归

如果在一个定义了中（如python的函数）引用了被定义的对象（被定义的函数）本身，这种定义被称为递归。在递归定义或结构中，递归的部分必须比原来的整体简单，这样才有可能到达某种终节点（即递归的出口）。显然，这种终节点不能是递归的。在递归结构中，必须存在非递归的基本结构构成的成分。如果不是这样就会出现无限递归。例如，节点链的空连接就是递归的终点。

##### **栈与递归/函数调用**
在程序执行中，函数的嵌套调用是按“后调用先返回的”规则进行，这种规则符合栈的使用模式，因此可以用栈来实现。
函数调用的前序动作按顺序包括：
- 被调用函数的局部变量和形式参数分配存储区（称为函数帧/活动记录/数据区）
- 将所有实参和函数的返回地址存入函数帧（实参形参的结合/传值）
- 将控制转到被调用函数的入口。
函数调用的后序动作（函数返回时完成）是：
- 被调用函数的计算结果存入指定位置。
- 释放被调用函数的存储区（帧）
- 按以前保存的返回地址将控制转回调用函数。

##### **栈与函数调用**

##### **递归与非递归**
对于递归定义的函数，每个实际调用时执行的都是该函数体的代码，只是需要在一个内部运行栈里保存各次调用的局部信息。这种情况说明，完全有可能修改函数定义，把一个递归定义的函数改造为一个非递归函数
递归定义的阶乘函数，与之对应的非递归形式，用自己定义的栈模拟系统的运行栈。


```
def norec_fac(n): # 自己管理栈，模拟函数调用过程
    res = 1
    st = SStack()
    while n > 0:
        st.push(n)
        n -= 1
    while not st.is_empty():
        res *= st.pop()
    return res123456789
```

##### **递归函数与非递归函数**
目前来说，函数调用损失的效率多半都可以接受，通常直接采用递归定义的函数就可以满足要求，不一定需要考虑非递归函数的定义。只有一些极为特殊的情况，由于效率要求特别高等原因，可能需要做这种工作。


###### **求解背包问题的递归算法**


```
def knap_rec(weight, wlist, n):
    if weight == 0:
        return True
    if weight < 0 or (weight > 0 and n < 1):
        return False
    if knap_rec(weight - wlist[n-1], wlist, n-1):
        print("Item " + str(n) + ":", wlist[n-1])
        return True
    if knap_rec(weight, wlist, n-1):
        return True
    else: return False1234567891011
```

### 5.4 队列

队列（queue），也是一种容器，可存入、访问、删除元素。

#### 5.4.1 队列抽象数据类型

（读者：仔细看书去！）

#### 5.4.2 队列的链接实现

（读者：仔细看书去！）

#### 5.4.3 队列的顺序表实现

（读者：仔细看书去！）

#### 5.4.4 队列的list实现

一个具体实现示例：基于Python的list实现顺序表示的队列。

##### **基本设计**

队列可能由于空而无法deque等，为此定义一个异常类：

```
class QueueUnderflow(ValueError):
    pass12
```

##### **数据不变式**

（读者：去看书吧）

##### **队列类的实现**

（读者：抄代码。。）

```
class SQueue():
    def __init__(self, init_len=8):
        self._len = init_len          # 存储区长度
        self._elems = [0]*init_len    # 元素存储
        self._head = 0                # 表头元素下标
        self._num = 0                 # 元素个数

    def is_empty(self):
        return self._num == 0

    def peek(self):
        if self._num == 0:
            raise QueueUnderflow
        return self._elems[self._head]

    def dequeue():
        if self._num == 0:
            raise QueueUnderflow
        e = self._elems[self._head]
        self._head = (self._head+1) % self.len
        self._num -= 1
        return e

    def enqueue(self, e):
        if self._num == self._len:
            self.__extend()
        self._elems[(self._head+self._num) % self._len] = e
        self._num += 1

    def __extend(self):
        old_len = self._len
        self._len *= 2
        new_elems = [0]*self._len
        for i in range(old_len):
            new_elems[i] = self._elems[(self._head+i)%old_len]
        self._elems, self._head = new_elems, 0  
```
