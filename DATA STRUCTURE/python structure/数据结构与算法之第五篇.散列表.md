## 第8章 字典和集合

### 8.1 数据存储、检索和集合

#### 8.1.1 数据存储和检索

##### **概述**

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192824301)

在一些专业书籍或编程语言里，字典也被称为查找表、映射或者关联表等。

##### **字典操作和效率**

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192837092)

##### **字典和索引**

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192836595)

#### 8.1.2 字典实现的问题

##### **字典抽象数据类型**

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192826627)

对于**动态字典**，还需支持**插入**和**删除**元素。

##### **字典元素：关联**

一个**数据项**就是一种**二元组**，下面称之为**关联**。

为了下面讨论的方便，现在首先定义一个关联对象的类Assoc，假定本章下面讨论的字典都以Assoc对象为元素：

```
class Assoc:
    def __init__(self, key, value):
        self.key = key
        self.value = value
    def ___lt__(self, other):    # 有时（有些操作）可能需要考虑序（表示less than）
        return self.key < other.key
    def __le__(self, other):
        return self.key < other.key or self.key == other.key
    def __str__(self):           # 定义字符串表示形式便于输出和交互（表示less than or equal to）
        return "Assoc({0}{1})".format(self.key, self.value)12345678910
```

##### **字典的实现**

### 8.2 字典线性表实现

#### 8.2.1 基本实现

#### 8.2.2 有序线性表和二分法检索

在元素有序的表上做二分法检索的函数可定义如下：

```
def bisearch(lst, key):
    low, high = 0, len(lst) - 1
    while low <= high:        # 范围内还有元素
        mid = low + (high - low) // 2
        if key == lst[mid].key:
            return lst[mid].value
        if key < lst[mid].key:
            high = mid - 1    # 在低半区继续
        else:
            low = mid + 1     # 在高半区继续12345678910
```

可以继承前面基于表的字典类，定义一个新的字典类：

```
class DictOrdList(DictList):
        ......
    def search(self, key):
        ......
    def insert(self, key, data):
        ......
    def delete(self, key):
        ......
    ......
# end of class12345678910
```

##### **二分法检索实例**

##### **算法分析**

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192826333)

#### 8.2.3 字典线性表总结

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192829183)

##### **问题和思考**

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192828587)

### 8.3 散列和散列表

首先讨论**散列技术**及其在字典方面的应用，即所谓的**散列表**（hash table）。

#### 8.3.1 散列的思想和应用

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192830232)

##### **散列思想在信息领域的应用**

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192848921)

##### **散列技术：设计和性质**

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192831037)
这说明，在通常情况下，**散列函数h**是一个从**大集合到小集合**的**映射**。

#### 8.3.2 散列函数

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192848558)

##### **用于整数关键码的若干散列方法**

###### **数字分析法**：

###### **折叠法**：

###### **中平方法**：

通俗地讲，**散列函数的映射关系越乱越好，越不清晰越好**

##### **常用散列函数**

两种常用的散列函数：
\- **除余法**，适用于**整数关键码**。
\- **基数转换法**，适用于**整数**或**字符串关键码**。

下面是用Python写出的一个字符串散列函数：

```
def str_hash(s):
    h1 = 0
    for c in s:
        h1 = h1 *29 + ord(c)
        """
        ord(c, /)
        Return the Unicode code point for a one-character string.
        示例：
        >>> ord('a')
        97
        """
    return h1123456789101112
```

#### 8.3.3 冲突的内消解：开地址技术

（读者：这一小节没有仔细看，下次好好看。）
冲突消解方法：
\- **内消解**方法（在**基本的存储区内部**解决冲突问题）。
\- **外消解**方法（在**基本的存储区之外**解决冲突）。

##### **开地址法和探查序列**

##### **开地址法示例**

##### **检索和删除**

#### 8.3.4 外消解技术

##### **溢出区方法**

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192833541)

##### **桶散列**

（读者：这里没仔细看。）

#### 8.3.5 散列表的性质

##### **扩大存储区，用空间交换时间**

##### **负载因子和操作效率**

##### **可能技术和实用情况**

### 8.4 集合

#### 8.4.1 集合的概念、运算和抽象数据类型

##### **概念和集合描述**

##### **集合运算**

##### **抽象数据类型**

![这里写图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87.%E6%95%A3%E5%88%97%E8%A1%A8.assets/SouthEast-20201201192837437)

#### 8.4.2 集合的实现

##### **简单线性表实现**

##### **排序顺序表实现**

假设需要求交集的集合S和T由两个Python的表s和t表示，结果集合用表r表示。求交集的算法（注意，这里假设s和t的元素都从小到大排列）：

```
r = []
i = 0    # i和j是s和t中下一次检查的元素的下标
j = 0
while i < len(s) and j < len(t):
    if s[i] < t[j]:
        i += 1
    elif t[j] < s[i]:
        j += 1
    else:    # s[i] = t[j]
        r.append(s[i])
        i += 1
        j += 1
    # 现在r就是得到的交集12345678910111213
```

##### **散列表实现**