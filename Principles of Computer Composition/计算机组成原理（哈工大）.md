# 第1章 计算机系统概论

## 1.1 计算机系统简介

#### 1.1.1概念

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70.png)

- 系统复杂性管理的方法
  - 抽象
    - 对过程或细节隐藏，以便把结构表达更清楚
  - 3`Y
    - 层次化：将被设计的系统划分为多个模块或子模块
    - 模块化：有明确定义的功能和接口
    - 规则性：模块更容易被重用

#### 1.1.2 计算机系统的层次结构

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201207193901212.png)

- 最早出现的语言只有机器语言（实际机器M1）
  - 0、1代码，缺点是编写难度大，操作过程容易出错
- 汇编语言，符号式代码(虚拟机器M2)
  - 但是没有机器能直接识别这种汇编程序
  - 翻译过程由机器系统软件中的汇编程序来完成
- 高级语言(虚拟机器M3)
  - 两种翻译方式：编译程序和解释程序
- 微指令程序(微程序机器M0)
  - M1向下延伸形成下一级的微程序机器M0，将机器语言的每一条机器指令翻译成一组微指令，即构成一个微程序
  - M0每执行完对应一条机器指令的一个微程序后，便由机器M1中的下一条机器指令使机器M0自动进入与其相对应的另一个微程序的执行。
  - 可见，M0是对实际机器M1的分解，即用M0的微程序解释并执行M1的每一条机器指令
  - 由于机器M0也是实际机器，为了区别于M1，将M1称为传统机器，将M0称为微程序机器
  - 这样又可以认为计算机系统具有四级层次结构
- 实际上在M1、M2中间还有一级虚拟机器，是操作系统软件构成的

```
graph TB
虚拟机器M4:用编译程序翻译成汇编语言程序 --> 虚拟机器M3:用汇编语言翻译成机器语言程序-->虚拟机器M2:用机器语言解释操作系统-->实际机器M1:用微指令解释机器指令-->微程序机器M0:由硬件直接执行微指令
```

- 计算机组成与计算机体系结构从研究内容上来说有什么区别？
- ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201207194347884.png)
  - 计算机系统结构：能够被程序员所见到的计算机系统的属性
    - 指令集
    - 数据类型
    - 存储器寻址技术
    - I/O机理等
    - 对于不同层次上编程的程序员，所看到的计算机属性也各不相同
  - 计算机组成：如何实现计算机体系结构所体现的属性
    - 包含了许多对程序员透明的硬件细节
    - 如：如何取指令、分析指令、取操作数、运算、送结果等，这些属于计算机组成问题
    - 但指令系统体现了机器属性，属于计算机结构问题
  - 一台机器**是否具备乘法指令的功能**，是一个结构问题
  - 乘法指令**采用什么方式**，是一个组成问题

## 1.2 计算机的基本组成

####  1.2.1 冯·诺依曼计算机的特点

- 以“存储程序”概念为基础的各类计算机通称冯·诺依曼机

  - 计算机由**五大部件**组成：
  - 运算器
  - 存储器
  - 控制器
  - 输入设备
  - 输出设备

- 指令和数据以**同等地位**存放在存储器内，并可按地址寻访

- 指令和数据均用**二进制数**表示

- 指令由**操作码**（操作性质）和**地址码**（操作数在存储器中的位置）组成

- 存储程序

- 机器**以运算器为中心**，输入输出设备与存储器的数据传输通过运算器完成

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191003221946297.png)

#### 1.2.2 计算机硬件框图

- 以运算器为中心
  - 运算器：完成算术运算和逻辑运算，中间结果暂存在运算器内
- 存储器：用来存放数据和程序
  - 控制器：用来控制、指挥程序和数据的输入、运行以及处理运算结果
  - 输入设备：常见的键盘、鼠标等。把人熟悉的信息形式转换为机器能识别的信息形式
  - 输出设备：打印机、显示器等。
- 以运算器为中心的机器缺点是，数据输入输出必须要经过运算器，运算器会成为计算机系统的瓶颈
- 对以运算器为中心的机器进行改进，改为以存储器为中心的计算机机器
  - –>控制线
  - ——>反馈线
  - ===》数据线

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E4%BB%A5%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83.png)

- 由于运算器（ALU）和控制器（CU）在逻辑关系和电路结构上联系十分紧密，通常合起来称为中央处理器（CPU）
- 把输入输出设备简称为I/O设备
- 存储器为又分主存和辅存（或称外存），主存储器存放程序和数据，可以直接与CPU交换信息
- 现代机器可以认为是三大部分组成：CPU、I/O设备以及主存储器

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191003221753149.png)

- ALU完成算术逻辑运算
- CU解释存储器中的指令，发出各种操作命令来执行指令
- I/O设备也受CU控制，用来完成输入、输出操作
- 计算机有条不紊地自动工作都是在**控制器统一指挥**下完成的

#### 1.2.3 计算机的工作步骤

- 用计算机解决一个实际问题通常包含两大步骤

  - 上机前的各种准备
    1. 建立数学模型
    2. 确定计算方式
    3. 编制解题程序
  - 上机运行

- 设某机器的指令字长为16位，其中操作码占6位（在CU中操作），地址码占10位（CU在操作码之后要操作（存、取）的数据的地址）

  | 操作码 | 地址码 |
  |:------:|:------:|
  | 6位    | 10位   |

  | 操作码 | 操作性质 | 具体内容                                 |
  |:------:| :------: | :------:|
  | 000001 | 取数     | 存储单元中保存的数据保存到ACC中          |
  | 000010 | 存数     | ACC中的数存到指令地址码的存储单元中      |
  | 000011 | 加       | ACC中的数语存储单元的数相加，保存到ACC中 |
  | 000100 | 乘       | ACC中的数与存储单元的数相乘，保存到ACC中 |
  | 000101 | 打印     | 将指令地址码指示的存储单元操作数打印输出 |
  | 000110 | 停机     | |

  对于一个求ax2+bx+c的解题过程可以分为以下步骤

| 指令和数据存于主存单元的地址 |               指令                | 注释                         |
| :--------------------------: | :-------------------------------: | ---------------------------- |
|              0               | 操作码：000001 地址码：0000001000 | 取数x至ACC                   |
|              1               |         000100 0000001001         | 乘a得ax，存于ACC中           |
|              2               |         000011 0000001010         | 加b得ax+b，存于ACC中         |
|              3               |         000100 0000001000         | 乘x得(ax+b)x，存于ACC中      |
|              4               |         000011 0000001011         | 加c得ax2+bx+c,存于ACC中      |
|              5               |         000010 0000001100         | 存数，将ax2+bx+c存于主存单元 |
|              6               |         000101 0000001100         | 打印                         |
|              7               |              000110               | 停机                         |
|              8               |                 x                 | 原始数据x                    |
|              9               |                 a                 | 原始数据a                    |
|              10              |                 b                 | 原始数据b                    |
|              11              |                 c                 | 原始数据c                    |
|              12              |                                   | 存放数据                     |

- **存储器的基本组成**

  - 存储体–存储单元–存储元件(0/1)
  - 类似于：大楼–房间–床位(无人/有人)
  - **存储单元**：存放一串二进制1代码
  - **存储字**：存储单元中二进制代码的组合
  - **存储字长**：存储单元中二进制代码的位数

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84.png)

- 主存的工作方式是按存储单元的地址号来实现对存储字各位的存、取，称为按地址存取方式

- MAR存储器地址寄存器，反映了存储单元的个数。**存放欲访问的存储单元的地址**（如MAR为10位，则有210=1024个存储单元）

- MDR存储器数据寄存器，反映存储字长。**存放从存储体某单元取出的代码或者准备往某存储单元存入的代码**

- **运算器的基本组成**

  - 最少包括3个寄存器和一个算术逻辑单元（ALU）
  - ACC为累加器
  - MQ为乘商寄存器
  - X为操作数寄存器

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E8%BF%90%E7%AE%97%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png)

  | | 加法 | 减法 | 乘法 | 除法 |
  | :--: | :--:  | :--:  | :--:  | :--:  |
  | ACC(初始就有) | 被加数及和 | 被减数及差 | 乘积高位 | 被除数及余数 |
  | MQ | | | 乘数及乘积低位 | 商 |
  | X | 加数 | 减数 | 被乘数 | 除数 |

  上表中的值为寄存器中的值

- 操作过程（[ ]代表该地址中的值，）

  - 加法：
    1. [M]->X
    2. [ACC]（被加数）+[X]（加数）->ACC
  - 减法
    1. [M]->X
    2. [ACC]（被减数）-[X]（减数）->ACC
  - 乘法
    1. [M]（乘数）->MQ
    2. [ACC]->X
    3. 0->ACC //清零
    4. [X]*[MQ]->ACC（高位）//MQ（低位）
  - 除法
    1. [M]（除数）->X
    2. [ACC]÷[X]->MQ
    3. 余数R在ACC中

- **控制器**

  - 控制器的功能：
    1. **解释指令**
    
    2. 保证指令的按序执行
    
       
    
       ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191004214810945.png)
  - 计算机的神经中枢，指挥各部件自动、协调地工作
    1. 首先，命令存储器**读出**一条**指令**，称为取指过程（或**取指阶段**）
    2. 接着，对这条**指令**进行**分析**，指出指令完成什么操作，并按**寻址特征**指明**操作数**地址，称为分析过程（或**分析阶段**）
    3. 最后，根据操作数所在的地址以及指令的操作码完成某种操作，称为执行过程（或**执行阶段**）

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%93%E6%9E%84.png)

  - PC中保存了当前要执行指令的地址，具有计数功能(PC)+1->PC，PC加几和机器的结构有关
  - IR存放当前要执行的指令，控制单元从中取出操作码
  - CU执行指令

- 取指经典过程：

  1. 取指的时候从PC开始，把要执行的指令取到IR当中
  2. 然后PC自动地把它的值指向下一个要取指的指令

- 运算器、控制器、存储器构成了什么？

  - 构成了计算机的主机

- **一条指令在主机上是如何完成的？**
  

以取数指令为例

1. **PC**把指令地址送给**MAR**
  2. 由**MAR**送给**存储体**
  3. 在控制器**CU**的控制下，**存储体**把指定存储单元中保存的取数指令取出来送去到**MDR**当中
  4. 控制器**CU**控制下，取出来的指令送入**IR**（1～4取指令）
  5. **IR**中指令的操作码部分分给**CU**
  6. **IR**中指令的地址码部分把地址取出送去**MAR**
  7. 由**MAR**送给**存储体**
  8. 在控制器的控制下，**存储体**把取数指令要取的数取出来送去到**MDR**当中
  9. 然后把数送去ACC（6～9执行指令）

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201208190705055.png)

以存数指令为例

  1. **PC**把指令地址送给**MAR**
  2. 由**MAR**送给**存储体**
  3. 在控制器**CU**的控制下，从**存储体**指定的存储单元中把这条指令取出来送去到**MDR**当中
  4. 控制器**CU**控制下，取出来的指令送入**IR**（1～4取指令）
  5. **IR**中指令的操作码部分分给**CU**，由CU对指令进行分析（分析指令）
  6. CU控制，把**IR**当中地址码部分送入**MAR**
  7. 由**MAR**送给**存储体**，告诉存储体，现在有一个数据要存进来，地址是多少
  8. 把**ACC**中的内容送入**MDR**
9. 在控制器控制下，把**MDR**中的数据存到**存储体**中（6～9执行指令）

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201208190726142.png)

- ax2+bx+c程序的运行过程

  - 将程序通过输入设备送至计算机
  - 程序首地址->PC
  - 启动程序运行
  - 取指令 PC->MAR->M->MDR->IR,（让PC+1->PC）
  - 分析指令(操作码)  OP(IR)->CU
  - 执行指令 Ad(IR)(地址部分)->MAR->M->MDR->ACC
  - 乘法指令过程······
  - ······
  - 打印结果
  - 停机

## 1.3 计算机硬件的主要技术指标

#### 1.3.1 机器字长

- 比如：两个8位二进制数做加法，结果是一个8位二进制，CPU一次能处理数据的位数是8位
- CPU一次能处理数据的位数，与CPU中的寄存器位数有关
- 机器字长越长，性能就越好

#### 1.3.2 运算速度

- 主频
- 核数，每个核支持的线程数
- 机器的速度可以由指令执行的速度来衡量
- 吉普森法TM=∑i=1nfiti ，Tm为机器运行速度；fi为第i种指令占全部操作的百分比数，ti为第i种指令的执行时间
- **CPI**，执行一条指令所需时钟周期数（机器主频的倒数）
- **IPC**，一个时钟周期可以完成多少个指标
- **MIPS**，每秒执行百万条指令，例：200万条指令，则记**2MIPS**
- **FLOPS**，每秒浮点运算次数
- 最直接的方法：看我们最常用的软件在不同机器上的运行速度

#### 1.3.3 存储容量

- 主存容量和辅存容量
- 主存容量
  - 存储容量 = 存储单元个数 * 存储字长
  
    如MAR = 10，MDR = 8即存储容量为$2^{10}*8 = 2^{13}$，1K*8位
  
    再如MAR = 16，MDR = 32即存储容量为$2^{16}*32 = 2^{21} = 2M位$，64K*32位
  - 字节数 ，如213b=1KB，221b=256KB
- 辅存容量
  
  - 80GB（1G = 1024 M = 210∗220=230）

# 第2章 计算机的发展及应用

## 2.1 计算机的发展史

- ENIAC，冯·诺依曼机器是在这个机器的研究过程中产出的
- 摩尔定律
  - 微芯片上集成的晶体管数目每三年翻两番
- 软件技术的兴起和发展
- 软件发展特点
  - 开发周期长
  - 制作成本昂贵
  - 检测软件产品质量的特殊性

## 2.2 计算机应用

- 科学计算和数据处理
- 工业控制和实时控制
- 网络技术
  - 电子商务
  - 网络教育
  - 敏捷制造
- 虚拟现实
- 办公自动化和管理信息系统
- CAD/CAM/CIMS
- 多媒体技术
- 人工智能

## 2.3 计算机的展望

- 计算机具有类似人脑的一些超级智能功能
  - 要求计算机的速度足够快
- 芯片集成度的提高受以下三方面限制
  - 芯片集成度物理极限的制约
  - 按几何级数数递增的制作成本
  - 芯片的功耗、散热、线延迟
- 替代传统的硅芯片
  - 光计算机
    - 利用光子取代电子进行运算和存储
  - DNA生物计算机
    - 通过控制DNA分子间的生化反应
  - 量子计算机
    - 利用原子所具有的量子特性

# 第3章 系统总线

## 3.1 总线的基本概念

- 什么是总线

  - 总线是连接各个部件的信息传输线，是各个部件共享的传输介质

- 总线上信息的传送

  - 串行：一位一位在总线上传送
  - 并行：多位同时，接收方也是多位
  - 串行长（多设备之间），并行短（集中在机箱内）

- 单总线结构计算机举例

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png)

  - 所有部件连接到一条总线上
  - 如果主存与I/O接口进行数据传输的话，主存和CPU之间就无法进行数据传输
  - 设备很多，系统总线会比较长

- 面向CPU的双总线结构

  - CPU和**I/O总线**相连，主存只和CPU通过**M总线**相连
  - CPU工作效率有所提高，但还是有缺点
  - 某一时刻各部件都要占用总线时，就会发生冲突（当io设备与主存通信还是会打断CPU的计算任务）

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209094121744.png)

- 以存储器为中心的双总线结构

  - 在单总线的基础上，CPU和主存都连接**系统总线**的同时再通过**存储总线**相连
  
  - 既提高了传输效率，又减轻了系统总线的负担，还保留了I/O设备与存储器交换信息时不经过CPU的特点
  
    ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209094308124.png)

## 3.2 总线的分类

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209094446406.png)

#### 3.2.1 片内总线

- 芯片内部的总线
  - 比如：CPU芯片内部：
  - 寄存器与寄存器之间
  - 寄存器与算逻单元ALU之间

#### 3.2.2 系统总线

- 指CPU、主存、I/O设备**各大计算机部件之间的信息传输线**

- 按传输信息不同，分为三类：数据总线、地址总线和控制总线

  1. 数据总线：**双向**传输，其位数与机器字长、存储字长有关，一般为8位、16位或32位

  2. 地址总线：**单向**传输，其位数与存储地址、I/O地址有关

  3. 控制总线：有输入，有输出

     常见的控制信号：

     - 时钟：同步各种操作
     - 复位：初始化所有部件
     - 总线请求：某部件获得总线使用权
     - 总线允许：需要获得总线使用权的部件已获得控制权
     - 中断请求：某部件提出中断请求
     - 中断响应：中断请求已被接收
     - 存储器写：将数据总线上的数据写至存储器的指定地址单元内
     - 存储器读：将指定存储单元中的数据读到数据总线上
     - I/O读：从指定的I/O端口将数据读到数据总线上
     - I/O写：将数据总线上的数据输出到指定的I/O端口内
     - 传输响应：数据已1被接收，或已将数据送至数据总线上

#### 3.2.3 通信总线

- 用于**计算机系统之间**或**计算机系统与其他系统之间**的通信
- 传输方式分为两种：**串行通信**和**并行通信**

## 3.3 总线特性及性能指标

#### 3.3.1 总线特性

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%A9%E7%90%86%E5%AE%9E%E7%8E%B0.png)

1. 机械特性

   - **尺寸**、形状、**管脚数**及**排列顺序**

2. 电气特性

   - 信号的**传输方向**和有效**电平**范围

3. 功能特性

   - 每根传输线的

     功能

     - 地址总线用来指出地址码
     - 数据总线用来传递数据
     - 控制总线发出控制信号

4. 时间特性

   - 信号的**时序**关系，一般可用信号时序图来描述

#### 3.3.2 总线性能指标

1. 总线宽度：**数据线**的根数，用bit表示，如8位、16位、32位、64位（即8根、16根、32根、64根）

2. 总线带宽（标准传输率）：每秒传输的最大字节数，单位MBps

   - 例：总线工作频率为33MHz，总线宽度为32位（4 B），则总线带宽位33*(32÷8)=132 MBps

3. 时钟同步/异步：同步、不同步

4. 总线复用：地址线与数据线复用

5. 信号线数：地址线、数据线和控制线的总和

6. 总线控制方式：突发、自动、仲裁、逻辑、计数

7. 其他指标：负载能力、电源电压、总线宽度能否扩展

#### 3.3.3 总线标准

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86.png)

## 3.4 总线结构

#### 3.4.1 单总线结构

- 导致的问题是总线成为系统的瓶颈

#### 3.4.2 多总线结构

1. 双总线结构

   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209100017047.png)

   - **CPU**和**主存**及**通道**通过主存总线相连
   - I/O接口、设备通过I/O总线相连
   - I/O总线与主存总线之间通过**通道**相连
   - 通道（具有特殊功能的处理器，对I/O统一管理）有自己的指令系统，可以执行一些简单的指令
     - 通道的程序通常情况下，是由操作系统来编写的，并不是由人工来编写的

2. 三总线结构

   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209100055223.png)

   - 直接存储器访问
   - CPU是中心，如果有一些高速设备和内存之间信息交换，可以通过DMA总线与主存交换信息高速运行，但是低速设备依然要通过I/O总线

3. 三总线结构的另一种形式
   ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%BD%A2%E5%BC%8F.png)

   - CPU和主存之间交换的量最大
   - CPU运行时的指令和数据主要是从Cache中获取
   - 扩展总线解决了I/O设备的扩展问题，但影响外部设备工作速度

4. 四总线结构

   ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   - 桥电路扩展出了高速总线，低速设备通过扩展总线连接到扩展总线，使数据传输速度更高

> 目前计算机都采用什么总线结构？采用哪些通信控制？
> 目前计算机多采用四总线结构：
> 局部总线：连接CPU与Cache/桥。
> 系统总线：连接Cache/桥与主存。
> 高速总线：连接Cache/桥与高速设备。
> 扩展总线：连接扩展总线接口与低速设备，其中扩展总线接口连接在高速总线上。
> 总线的通信控制包括：
> 同步通信：由统一时标控制数据传送。
> 异步通信：采用应答方式，没有公共时钟标准。
> 半同步通信：同步、异步相结合。
> 分离式通信：充分挖掘系统总线每个瞬间的潜力，特别是利用传数阶段准备数据时的总线空闲。

## 3.5 总线控制

#### 3.5.1 总线判优控制 （总线调度）

- 基本概念

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191006185748480.png)

- 链式查询方式

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209101650528.png)

  - 如果有一个设备占用了总线，就通过总线忙告诉其他总线
  - 顺序是BR->BG->BR
  - 每个设备的优先级和BG有直接关系，连接方式确定的

  
  > 特点：只需要很少几根线皆可以按一定优先次序实现总线控制，易扩充设备，但对电路故障很敏感。


- 计数器定时查询方式

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209101740720.png)

  - 总线控制部件里面有一个计数器，它的初值可以是0，也可以是其他值
  - 顺序是BR->接口0没有提出请求，计数器+1，看接口1有没有提出请求->通过设备地址线，项各设备发出一组地址信号，设备地址和计数器值匹配时，获得总线使用权->BS
  - 优先级可以通过设定计数器初值，循环进行
  - 设备地址线需要log2n条线

  > 特点：计数可以从0开始，设备优先次序就是固定的；也可由终点开始，即是一种循环方法；设备优先级相等；初始值也可由程序设置，故优先次序可以改变。对电路敏感不如链式，但增加了主控制线(设备地址)数，控制比较复杂。

- 独立请求方式

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209102126175.png)

  - 任何一个I/O接口都连接BR、BG
  - 总线控制部件中排队器
  - 顺序是多个BR同时发出总线请求->优先级排队
  
  > 特点：响应快，优先次序控制灵活(通过程序改变)，但控制线数量多，总线控制更复杂。
  >  
  > 另外，链式查询仅用两根线确定总线使用权属于哪个设备，计数查询大致用 〖log〗_2⁡n 跟线，而独立请求方式需采用 2n 跟线，其中n指最大设备数。

#### 3.5.2 总线通信控制(通信)

- 目的：解决通信双方**协调配合**问题

- **总线传输周期（传输过程）**

  - 申请分配阶段：**主模块申请**，总线总裁决定
  - 寻址阶段：主模块向从模块**给出地址**和**命令**
  - 传数阶段：主模块和从模块**交换数据**
  - 结束阶段：主模块撤销有关信息，让出总线使用权

- 总线通信的四种方式

  - 同步通信：由**统一时标**控制数据传送
  - 异步通信：采用**应答方式**，没有公共时钟标准
  - 半通信同步：同步、异步结合
  - 分离式通信：充分**挖掘**系统**总线每个瞬间**的潜力

- 同步式数据输入

  <img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209103059913.png" alt="在这里插入图片描述"  />

  - 在T1时钟的上升沿，必须要给出地址信号
  - 在T2上升沿必须给出读命令信号
  - 在T3上升沿到达前，从设备必须要给出数据信号，通过数据总线来传输
  - 在T3时钟周期内，将数据线上的信息送到其内部寄存器中
  - 在T4上升沿1到达前，数据信号和控制信号撤销
  - 在T4结束的时候，地址信号也撤销了

  > 它的特点是：
  >
  > - 一定要有定宽定距的时钟来控制整个数据传输的过程
  > - 要在给定的时间点上完成一些相应的操作

- 同步式数据输出

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E4%BC%A0%E8%BE%93.png)

  - 在T1上升沿给出地址信号
  - 在T1下降沿要给出数据
  - 在T2上升沿要给出写命令
  - 在T3时钟周期进行这些操作
  - 在T4上升沿，撤销数据和写命令
  - T4结束时，把地址信息也撤掉

- 同步通信优点：

  - 规定明确、统一，模块间的配合简单一致

- 同步通信缺点：

  - 主、从模块时间强制性同步
  - 必须按照最慢速度的部件来设计公共时钟

- 同步通信一般用于总线长度较短、各部件存取时间比较一致的场合

  - 因为在同步通信的总线系统中，总线的传输周期越短，数据线的位数越多，直接影响总线的数据传输率
  - 总线长度来讲,必须按距离最长的两个设备的传输延迟来设计公共时钟。但是总线长了势必降低传输频率，所以同步通信一般用于总线长度较短的场合

- 异步通信

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%BA%94%E7%AD%94%E6%96%B9%E5%BC%8F.png)

  - 不互锁：应用例子CPU向主存写信息，CPU要先给出地址信号、写命令以及写入数据，用此方式
  - 半互锁：多机系统（类似于三次握手）
  - 全互锁：网络通信（仅类似于四次挥手）

- 半同步通信（同步、异步结合）

  - 同步：

    - **发送方**用系统**时钟前沿**发信息
    - **接收方**用系统**时钟后沿**判断、识别

  - 异步

    - 允许不同速度的模块和谐工作
    - 为了调整主从设备差异速度的差异，增加了一条“等待”响应信号**WAIT**

  - 以输入数据为例的半同步通信时序

    ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.png)

    - T1 主模块发地址
    - T2 主模块发命令
    - Tw 从设备数据还没准备好，从模块使**WAIT**为低电平，主模块检测到低电平等待一个T
    - Tw **WAIT**为低电平，等待一个T
    - 。。。。。。
    - T3 从模块提供数据
    - T4 从模块撤销数据，主模块撤销命令

- 以上三种通信的共同点

  - 一个总线传输周期（以输入数据为例）
    - 从模块发地址、命令 **占用总线**
    - 从模块准备数据 **不占用总线**
    - 从模块向主模块发数据 **占用总线**

- 分离式通信

  - 充分挖掘系统总线每个瞬间的潜力
  - 一个总线传输周期（**让出了准备数据的时间**，**让总线干别的事**）
    - 子周期1:主模块申请占用总线，使用完后即放弃总线的使用权
    - 子周期2:从设备申请占用总线，将各种信息送至总线上
  - 特点：
    1. 各模块都有权申请占用总线
    2. 采用同步通信，不等对方回答
    3. 各模块准备数据时，不占用总线
    4. 总线被占用时，无空闲

# 第4章 存储器

## 4.1 概述

#### 4.1.1 存储器分类

- 按存储介质分类（半导体，磁，光）

  1. (1) 半导体存储器  TTL 、 MOS               易失
     (2) 磁表面存储器  磁头、载磁体            \
     (3) 磁芯存储器    硬磁材料、环状元件      非易失
     (4) 光盘存储器    激光、磁光材料         /

- 按存取方式分类

  1. 随机存储器（在程序的执行过程中 可 读 可 写）
  2. 只读存储器（在程序的执行过程中 只 读）
  3. 串行访问存储器
     1. 顺序存取存储器（磁带）
     2. 直接存取存储器（磁盘）

- 按在计算机中的作用分类

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%AD%98%E5%82%A8%E5%99%A8%E6%8C%89%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB.png)



#### 4.1.2 存储器的层次结构

- 存储器3个主要性能指标：速度、容量、位价

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209110700477.png)

- 层次结构主要体现在缓存-主存和主存-辅存这两个存储层次上

  ![image-20201209111634331](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/image-20201209111634331.png)

  - 缓存-主存层次解决CPU和主存速度不匹配，使速度接近缓存，高于主存
  - 主存-辅存层次解决存储系统的容量问题（虚拟内存 -操作系统）

## *4.2 主存储器

#### 4.2.1 概述

- 主存的基本组成

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209111934195.png)

- 主存和CPU的联系

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E7%9A%84%E8%81%94%E7%B3%BB.png)

  备注：MDR、MAR在CPU中

- 主存中存储单元地址的分配

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209112307419.png)

  - 大端、小端方式
  - 设地址线24根，按**字节**寻址$2^{24}$=16MB
  - 若字长为16位，按字寻址8M字
  - 若字长为32位，按字寻址4M字

- 主存的技术指标

  - 存储容量：主存、存放二进制代码的总位数
  - 存储速度：
    - 存取时间：存储器的访问时间（读出时间、写入时间）
    - 存取周期：连续两次独立的存储器操作（读或写）所需的最小间隔时间（读周期、写周期），存取周期＞存取时间
  - 存储器的带宽：位/秒

#### 4.2.2 半导体存储芯片简介

- 基本结构
  
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209113349590.png)
  
  - 地址线单向输入，数据线双向
    - 例如：地址线10根，数据线4根，则芯片容量=$2^{10}$∗4=4K
    - 又例如：地址线14根，数据线1根，则容量为16K
  - 存储芯片片选线的作用
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191012131144209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70)
  
- 线选法：一根字选择线，直接选中一个存储单元的各位(16*1字节:1片)

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209113931533.png)

- 重合法：所选单元由X、Y（行列地址）两个方向决定 (1K *1位:8片芯片)

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209113942007.png)

#### 4.2.3 随机存取存储器（RAM）

- 静态RAM(SRAM)
  **静态 RAM 芯片举例**
  Intel 2114 外特性
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209114516324.png)② Intel 2114 RAM 矩阵 (64 × 64) 读
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209114516599.png)

   Intel 2114 RAM 矩阵 (64 × 64) 写
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191012132643730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70)

- 动态RAM(DRAM)
  
  ①三管动态 RAM 芯片 (Intel 1103) 读
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191012132834370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70)② 三管动态 RAM 芯片 (Intel 1103) 写
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191012132901384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70)
  
  - 电容上保存的有电荷1，无电荷0
  - 动态RAM刷新
    - 与行地址有关，与列地址无关，每次刷新都刷新一行的数据
    - 有些存储单元长期得不到访问，不进行存储器的读/写操作，存储单元内的原信息将会慢慢消失，为此，必须采用定时刷新的方法
    - 集中刷新（存取周期为0.5µs）：规定一个刷新周期，此周期内停止读/写操作，这个周期又称访存死区
    - 分散刷新：每行存储单元的刷新分散到每个存取周期内完成
    - 异步刷新（结合分散刷新与集中刷新）：将刷新安排在指令译码阶段，不会出现”死区“
  
- 动态和静态比较

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209150239243.png)

#### 4.2.4 只读存储器（ROM）

- 掩模ROM（MROM）
  - 行列选择线交叉处有MOS管为“1”，无为“0”
- PROM（一次性编程）
  - 熔丝断为“0”，未断为“1”
  - 是一种破坏性编程
- EPROM（多次性编程）
  - N型沟道浮动栅MOS电路
    - D端加正电压，形成浮动栅，S和D不导通
    - D端不加正电压，S与D导通为“1”
  - 改写方法：紫外线照射
  - 价格便宜1，集成度高
- EEPROM（多次性编程）
  - 电可擦写：可局部擦写也可全部擦写
- Flash Memory（闪速型存储器）
  - 比EEPROM快，具备RAM功能

#### *4.2.5 存储器与CPU的连接

1. **存储器容量的扩展**

   1. 位扩展（增加存储字长）

      用2片 1Kx4位 存储芯片组成 1Kx8位 的存储器

      - 地址线连接方式完全相同
      - 数据线各占了按序的4位

   2. 字扩展（增加存储字的数量）

      用2片 1Kx8位 存储芯片组成 2Kx8位 的存储器

      - 数据线连接相同
      - 地址线一条用作片选信号，选择通过电平高低进行选择

   3. 字、位扩展

      用8片 1Kx4位 的芯片组成 4Kx8位 的存储器

      - 两个一组先构成8位的存储字长
      - 分为4组，通过两根地址线经过译码器得到4个片选信号
      
      ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151003017.png)

2. **存储器与CPU的连接**

   1. 地址线的连接
   2. 数据线的连接
   3. 读写命令线的连接
   4. 片选线的连接
   5. 合理选择存储芯片
   6. 其他：时序、负载

> **例4.1** 设CPU有**16根地址线**,8根数据线，并用 (MREQ) ̅ 作为访存控制信号(低电平有效),用用 (WR) ̅ 作为读/写控制信号(高电平为读,低电平为写)。现有下列存储芯片:1K*4位RAM,4K*8位RAM,8K*8位RAM,2K*8位ROM,4K*8ROM,8 K*8位ROM及74138译码器和各种门电路,如图所示。画出CPU与存储器的连接图,要求如下:
> ①主存地址空间分配：
> 6000H~67FFH为系统程序区。
> 6800H~6BFFH为用户程序区。
> ②合理选用上述存储芯片，说明各选几片。
> ③详细画出存储芯片的片选逻辑图。
> ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151043583.png)
> ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151043965.png)
> (3) 分配地址线
> ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151043771.png)
> (4) 确定片选信号
> ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151043857.png)
> 备注：MREQ存储器请求，确定本次访问时存储器(低电平)还是I/O(高电平)。(WR) ̅ 代表低电平为写，高电平为读。连接连个RAM的时候还得保证A10为低电平才行。

#### 2.6 存储器的校验

- 为什么要对存储器的信息进行校验？
- 为了能够校验出信息是否正确，如何进行编码？
- 纠错或检错能力与什么因素有关？
- 校验出信息出错后是如何进行纠错？
- 除了我们教材上讲的校验码，你还知道哪些容错编码？，原理是什么？
  
- 合法代码集合
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151044402.png)

1. 编码的最小距离
   任意两组合法代码之间二进制位数的最少差异
   编码的纠错、检错能力与编码的最小距离有关
   L − 1 = D + C ( D ≥ C ) 
   *L* —— 编码的最小距离 L = 3 
   *D* —— 检测错误的位数
   *C* —— 纠正错误的位数
   汉明码是具有一位纠错能力的编码

2. 汉明码的组成
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151044222-7497844.png)
   **组成汉明码的三要素**
   汉明码的组成需增添 ？

   *k*位检测位 $2^k$ ≥ n + k + 1,*n*为代码长度
   检测位的位置 ？ 

   $2^i$ ( i = 0 ， 1 ， 2 ， 3 ， … i = 0， 1， 2 ， 3 ， …*i*=0，1，2，3，… )
   检测位的取值 ？

   与该位所在的检测“小组” 中承担的奇偶校验任务有关
    
   **各检测位 C i C_i\*C\**i\*​ 所承担的检测小组为**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151043830.png)

3. 汉明码的纠错过程

![image-20201209160139222](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/image-20201209160139222.png)

![image-20201209160348125](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/image-20201209160348125.png)

**不出错时 P1 = 0 ， P2 = 0 ， P4 = 0** 

#### 2.7 提高访存速度的措施

- 采用高速器件
- 采用层次结构 Cache –主存
- 调整主存结构

1. 单体多字系统
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013121517436.png)
2. 多体并行系统
   (1) 高位交叉 顺序编址 各个体并行工作
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151044080.png)
   
   (2) 低位交叉 各个体轮流编址
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151044290.png)
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151044336.png)
   **低位交叉的特点**
   在不改变存取周期的前提下，增加存储器的带宽
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70.png)
   设四体低位交叉存储器，存取周期为T，总线传输周期为τ，为实现流水线方式存取，应满足 T ＝ 4τ。
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201209151044440.png)
   连续读取 4 个字所需的时间为T＋(4 －1)τ
3. 高性能存储芯片
   **(1) SDRAM (同步 DRAM)**
   在系统时钟的控制下进行读出和写入
   CPU 无须等待
   **(2) RDRAM**
   由 Rambus开发，主要解决存储器带宽问题
   **(3) 带 Cache 的 DRAM**
   在DRAM的芯片内集成了一个由 SRAM 组成的Cache，有利于猝发式读取

### 三、高速缓冲存储器

#### 3.1 概述

1. 问题的提出
   避免 CPU “空等” 现象
    
   CPU 和主存（DRAM） 的速度差异
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013114601398.png)
2. Cache的工作原理
   **(1) 主存和缓存的编址**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160712681.png)
   主存和缓存按块存储块的大小相同B为块长
    
   **(2) 命中与未命中**
   缓存共有C 块，主存共有M 块 M >> C
   **命中**：主存块调入缓存，主存块与缓存块建立了对应关系
   用标记记录与某缓存块建立了对应关系的主存块号
   **未命中**：主存块未调入缓存
   主存块与缓存块未建立对应关系
    
   **(3) Cache 的命中率**
   CPU 欲访问的信息在Cache 中的比率
   命中率与Cache 的容量与块长有关
   一般每块可取 4 ~ 8 个字
   块长取一个存取周期内从主存调出的信息长度
   CRAY_1：16体交叉，块长取 16 个存储字
   IBM 370/168：4体交叉，块长取 4 个存储字(64位× 4 = 256位)
    
   **(4) Cache–主存系统的效率**
   效率 e 与 命中率 有关
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013115025612.png)
   设 Cache 命中率 为 h， 访问 Cache 的时间为 tc，访问 主存 的时间为 tm，则
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013115046542.png)
3. Cache 的基本结构
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713000.png)
4. Cache的读写操作 -读
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713002.png)
   **写 - Cache 和主存的一致性**
   • **写直达法**（Write–through）
   写操作时数据既写入Cache又写入主存
   写操作时间就是访问主存的时间， Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现
   • **写回法**（Write–back）
   写操作时只把数据写入 Cache 而不写入主存
   当 Cache 数据被替换出去时(原数据)才写回主存
   写操作时间就是访问 Cache 的时间，
   Cache块退出时，被替换的块需写回主存，增加了Cache的复杂性
5. Cache 的改进
   **(1) 增加 Cache 的级数**
   • 片载（片内）Cache 单一缓存
   • 片外Cache 两级缓存
   **(2) 统一缓存和分立缓存**
   • 指令Cache 数据Cache
   • 与指令执行的控制方式有关 是否流水

#### 3.2 Cache–主存的地址映射

1. 直接映射
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713572.png)
   每个缓存块 *i* 可以和若干个主存块对应
   每个主存块 *j* 只能和一个缓存块对应
2. 全相联映射
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713496.png)
   主存中的任一块可以映射到缓存中的任一块
3. 组相联映射
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713848.png)
   **直接**：某一主存块只能固定映射到某一缓存块（靠近CPU）
   **全相联**：某一主存块能映射到任一缓存块（距离CPU最远）
   **组相联**：某一主存块只能映射到某一缓存组中的任一块（与CPU距离中等）

#### 3.3 替换算法

1. 先进先出 （ FIFO ） 算法
2. 近期最少使用（ LRU） 算法

### 四、辅助存储器

#### 4.1 概述

1. 特点 不直接与 CPU 交换信息
2. 磁表面存储器的技术指标
   (1) 记录密度 道密度 Dt 位密度 Db
   (2) 存储容量 C = n × k × s
   (3) 平均寻址时间 寻道时间 + 等待时间
   辅存的速度 寻址时间&磁头读写时间
   (4) 数据传输率 Dr = Db × V
   (5) 误码率 出错信息位数与读出信息的总位数之比

#### 4.2磁记录原理和记录方式

1. 磁记录原理 (读和写)
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013121832221.png)
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713720.png)

#### 4.3 硬磁盘存储器

1. 硬磁盘存储器的类型
   (1) 固定磁头和移动磁头
   (2) 可换盘和固定盘
2. 硬磁盘存储器结构
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013115844349.png)
   **(1) 磁盘驱动器**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713911.png)
   **(2) 磁盘控制器**
   • 接收主机发来的命令，转换成磁盘驱动器的控制命
   • 实现主机和驱动器之间的数据格式转换
   • 控制磁盘驱动器读写
   磁盘控制器 是主机与磁盘驱动器之间的 接口
    
   **(3) 盘片 由硬质铝合金材料制成**

#### 4.4 软磁盘存储器

1. 概述
   ![2.](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013122245826.png)
2. 软盘片——由聚酯薄膜制成
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160714434.png)

#### 4.5 光盘存储器

1. 概述
   采用光存储技术——利用激光写入和读出
   第一代光存储技术——采用非磁性介质 不可擦写
   第二代光存储技术——采用磁性介质 可擦写
2. 光盘的存储原理
   只读型和只写一次型——热作用（物理或化学变化）
   可擦写光盘——热磁效应