# 第1章 计算机系统概论

## 1.1 计算机系统简介

#### 1.1.1概念

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70.png)

- 系统复杂性管理的方法
  - 抽象
    - 对过程或细节隐藏，以便把结构表达更清楚
  - 3`Y
    - 层次化：将被设计的系统划分为多个模块或子模块
    - 模块化：有明确定义的功能和接口
    - 规则性：模块更容易被重用

#### 1.1.2 计算机系统的层次结构

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201207193901212.png)

- 最早出现的语言只有机器语言（实际机器M1）
  - 0、1代码，缺点是编写难度大，操作过程容易出错
- 汇编语言，符号式代码(虚拟机器M2)
  - 但是没有机器能直接识别这种汇编程序
  - 翻译过程由机器系统软件中的汇编程序来完成
- 高级语言(虚拟机器M3)
  - 两种翻译方式：编译程序和解释程序
- 微指令程序(微程序机器M0)
  - M1向下延伸形成下一级的微程序机器M0，将机器语言的每一条机器指令翻译成一组微指令，即构成一个微程序
  - M0每执行完对应一条机器指令的一个微程序后，便由机器M1中的下一条机器指令使机器M0自动进入与其相对应的另一个微程序的执行。
  - 可见，M0是对实际机器M1的分解，即用M0的微程序解释并执行M1的每一条机器指令
  - 由于机器M0也是实际机器，为了区别于M1，将M1称为传统机器，将M0称为微程序机器
  - 这样又可以认为计算机系统具有四级层次结构
- 实际上在M1、M2中间还有一级虚拟机器，是操作系统软件构成的

```
graph TB
虚拟机器M4:用编译程序翻译成汇编语言程序 --> 虚拟机器M3:用汇编语言翻译成机器语言程序-->虚拟机器M2:用机器语言解释操作系统-->实际机器M1:用微指令解释机器指令-->微程序机器M0:由硬件直接执行微指令
```

- 计算机组成与计算机体系结构从研究内容上来说有什么区别？
- ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201207194347884.png)
  - 计算机系统结构：能够被程序员所见到的计算机系统的属性
    - 指令集
    - 数据类型
    - 存储器寻址技术
    - I/O机理等
    - 对于不同层次上编程的程序员，所看到的计算机属性也各不相同
  - 计算机组成：如何实现计算机体系结构所体现的属性
    - 包含了许多对程序员透明的硬件细节
    - 如：如何取指令、分析指令、取操作数、运算、送结果等，这些属于计算机组成问题
    - 但指令系统体现了机器属性，属于计算机结构问题
  - 一台机器**是否具备乘法指令的功能**，是一个结构问题
  - 乘法指令**采用什么方式**，是一个组成问题

## 1.2 计算机的基本组成

####  1.2.1 冯·诺依曼计算机的特点

- 以“存储程序”概念为基础的各类计算机通称冯·诺依曼机

  - 计算机由**五大部件**组成：
  - 运算器
  - 存储器
  - 控制器
  - 输入设备
  - 输出设备

- 指令和数据以**同等地位**存放在存储器内，并可按地址寻访

- 指令和数据均用**二进制数**表示

- 指令由**操作码**（操作性质）和**地址码**（操作数在存储器中的位置）组成

- 存储程序

- 机器**以运算器为中心**，输入输出设备与存储器的数据传输通过运算器完成

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191003221946297.png)

#### 1.2.2 计算机硬件框图

- 以运算器为中心
  - 运算器：完成算术运算和逻辑运算，中间结果暂存在运算器内
- 存储器：用来存放数据和程序
  - 控制器：用来控制、指挥程序和数据的输入、运行以及处理运算结果
  - 输入设备：常见的键盘、鼠标等。把人熟悉的信息形式转换为机器能识别的信息形式
  - 输出设备：打印机、显示器等。
- 以运算器为中心的机器缺点是，数据输入输出必须要经过运算器，运算器会成为计算机系统的瓶颈
- 对以运算器为中心的机器进行改进，改为以存储器为中心的计算机机器
  - –>控制线
  - ——>反馈线
  - ===》数据线

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E4%BB%A5%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83.png)

- 由于运算器（ALU）和控制器（CU）在逻辑关系和电路结构上联系十分紧密，通常合起来称为中央处理器（CPU）
- 把输入输出设备简称为I/O设备
- 存储器为又分主存和辅存（或称外存），主存储器存放程序和数据，可以直接与CPU交换信息
- 现代机器可以认为是三大部分组成：CPU、I/O设备以及主存储器

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191003221753149.png)

- ALU完成算术逻辑运算
- CU解释存储器中的指令，发出各种操作命令来执行指令
- I/O设备也受CU控制，用来完成输入、输出操作
- 计算机有条不紊地自动工作都是在**控制器统一指挥**下完成的

#### 1.2.3 计算机的工作步骤

- 用计算机解决一个实际问题通常包含两大步骤

  - 上机前的各种准备
    1. 建立数学模型
    2. 确定计算方式
    3. 编制解题程序
  - 上机运行

- 设某机器的指令字长为16位，其中操作码占6位（在CU中操作），地址码占10位（CU在操作码之后要操作（存、取）的数据的地址）

  | 操作码 | 地址码 |
  |:------:|:------:|
  | 6位    | 10位   |

  | 操作码 | 操作性质 | 具体内容                                 |
  |:------:| :------: | :------:|
  | 000001 | 取数     | 存储单元中保存的数据保存到ACC中          |
  | 000010 | 存数     | ACC中的数存到指令地址码的存储单元中      |
  | 000011 | 加       | ACC中的数语存储单元的数相加，保存到ACC中 |
  | 000100 | 乘       | ACC中的数与存储单元的数相乘，保存到ACC中 |
  | 000101 | 打印     | 将指令地址码指示的存储单元操作数打印输出 |
  | 000110 | 停机     | |

  对于一个求ax2+bx+c的解题过程可以分为以下步骤

| 指令和数据存于主存单元的地址 |               指令                | 注释                         |
| :--------------------------: | :-------------------------------: | ---------------------------- |
|              0               | 操作码：000001 地址码：0000001000 | 取数x至ACC                   |
|              1               |         000100 0000001001         | 乘a得ax，存于ACC中           |
|              2               |         000011 0000001010         | 加b得ax+b，存于ACC中         |
|              3               |         000100 0000001000         | 乘x得(ax+b)x，存于ACC中      |
|              4               |         000011 0000001011         | 加c得ax2+bx+c,存于ACC中      |
|              5               |         000010 0000001100         | 存数，将ax2+bx+c存于主存单元 |
|              6               |         000101 0000001100         | 打印                         |
|              7               |              000110               | 停机                         |
|              8               |                 x                 | 原始数据x                    |
|              9               |                 a                 | 原始数据a                    |
|              10              |                 b                 | 原始数据b                    |
|              11              |                 c                 | 原始数据c                    |
|              12              |                                   | 存放数据                     |

- **存储器的基本组成**

  - 存储体–存储单元–存储元件(0/1)
  - 类似于：大楼–房间–床位(无人/有人)
  - **存储单元**：存放一串二进制1代码
  - **存储字**：存储单元中二进制代码的组合
  - **存储字长**：存储单元中二进制代码的位数

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84.png)

- 主存的工作方式是按存储单元的地址号来实现对存储字各位的存、取，称为按地址存取方式

- MAR存储器地址寄存器，反映了存储单元的个数。**存放欲访问的存储单元的地址**（如MAR为10位，则有210=1024个存储单元）

- MDR存储器数据寄存器，反映存储字长。**存放从存储体某单元取出的代码或者准备往某存储单元存入的代码**

- **运算器的基本组成**

  - 最少包括3个寄存器和一个算术逻辑单元（ALU）
  - ACC为累加器
  - MQ为乘商寄存器
  - X为操作数寄存器

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E8%BF%90%E7%AE%97%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png)

  | | 加法 | 减法 | 乘法 | 除法 |
  | :--: | :--:  | :--:  | :--:  | :--:  |
  | ACC(初始就有) | 被加数及和 | 被减数及差 | 乘积高位 | 被除数及余数 |
  | MQ | | | 乘数及乘积低位 | 商 |
  | X | 加数 | 减数 | 被乘数 | 除数 |

  上表中的值为寄存器中的值

- 操作过程（[ ]代表该地址中的值，）

  - 加法：
    1. [M]->X
    2. [ACC]（被加数）+[X]（加数）->ACC
  - 减法
    1. [M]->X
    2. [ACC]（被减数）-[X]（减数）->ACC
  - 乘法
    1. [M]（乘数）->MQ
    2. [ACC]->X
    3. 0->ACC //清零
    4. [X]*[MQ]->ACC（高位）//MQ（低位）
  - 除法
    1. [M]（除数）->X
    2. [ACC]÷[X]->MQ
    3. 余数R在ACC中

- **控制器**

  - 控制器的功能：
    1. **解释指令**
    
    2. 保证指令的按序执行
    
       
    
       ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191004214810945.png)
  - 计算机的神经中枢，指挥各部件自动、协调地工作
    1. 首先，命令存储器**读出**一条**指令**，称为取指过程（或**取指阶段**）
    2. 接着，对这条**指令**进行**分析**，指出指令完成什么操作，并按**寻址特征**指明**操作数**地址，称为分析过程（或**分析阶段**）
    3. 最后，根据操作数所在的地址以及指令的操作码完成某种操作，称为执行过程（或**执行阶段**）

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%93%E6%9E%84.png)

  - PC中保存了当前要执行指令的地址，具有计数功能(PC)+1->PC，PC加几和机器的结构有关
  - IR存放当前要执行的指令，控制单元从中取出操作码
  - CU执行指令

- 取指经典过程：

  1. 取指的时候从PC开始，把要执行的指令取到IR当中
  2. 然后PC自动地把它的值指向下一个要取指的指令

- 运算器、控制器、存储器构成了什么？

  - 构成了计算机的主机

- **一条指令在主机上是如何完成的？**
  
以取数指令为例
  
1. **PC**把指令地址送给**MAR**
  2. 由**MAR**送给**存储体**
  3. 在控制器**CU**的控制下，**存储体**把指定存储单元中保存的取数指令取出来送去到**MDR**当中
  4. 控制器**CU**控制下，取出来的指令送入**IR**（1～4取指令）
  5. **IR**中指令的操作码部分分给**CU**
  6. **IR**中指令的地址码部分把地址取出送去**MAR**
  7. 由**MAR**送给**存储体**
  8. 在控制器的控制下，**存储体**把取数指令要取的数取出来送去到**MDR**当中
  9. 然后把数送去ACC（6～9执行指令）
  
![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201208190705055.png)
  
以存数指令为例
  
  1. **PC**把指令地址送给**MAR**
  2. 由**MAR**送给**存储体**
  3. 在控制器**CU**的控制下，从**存储体**指定的存储单元中把这条指令取出来送去到**MDR**当中
  4. 控制器**CU**控制下，取出来的指令送入**IR**（1～4取指令）
  5. **IR**中指令的操作码部分分给**CU**，由CU对指令进行分析（分析指令）
  6. CU控制，把**IR**当中地址码部分送入**MAR**
  7. 由**MAR**送给**存储体**，告诉存储体，现在有一个数据要存进来，地址是多少
  8. 把**ACC**中的内容送入**MDR**
9. 在控制器控制下，把**MDR**中的数据存到**存储体**中（6～9执行指令）
  
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201208190726142.png)
  
- ax2+bx+c程序的运行过程

  - 将程序通过输入设备送至计算机
  - 程序首地址->PC
  - 启动程序运行
  - 取指令 PC->MAR->M->MDR->IR,（让PC+1->PC）
  - 分析指令(操作码)  OP(IR)->CU
  - 执行指令 Ad(IR)(地址部分)->MAR->M->MDR->ACC
  - 乘法指令过程······
  - ······
  - 打印结果
  - 停机

## 1.3 计算机硬件的主要技术指标

#### 1.3.1 机器字长

- 比如：两个8位二进制数做加法，结果是一个8位二进制，CPU一次能处理数据的位数是8位
- CPU一次能处理数据的位数，与CPU中的寄存器位数有关
- 机器字长越长，性能就越好

#### 1.3.2 运算速度

- 主频
- 核数，每个核支持的线程数
- 机器的速度可以由指令执行的速度来衡量
- 吉普森法TM=∑i=1nfiti ，Tm为机器运行速度；fi为第i种指令占全部操作的百分比数，ti为第i种指令的执行时间
- **CPI**，执行一条指令所需时钟周期数（机器主频的倒数）
- **IPC**，一个时钟周期可以完成多少个指标
- **MIPS**，每秒执行百万条指令，例：200万条指令，则记**2MIPS**
- **FLOPS**，每秒浮点运算次数
- 最直接的方法：看我们最常用的软件在不同机器上的运行速度

#### 1.3.3 存储容量

- 主存容量和辅存容量
- 主存容量
  - 存储容量 = 存储单元个数 * 存储字长
  
    如MAR = 10，MDR = 8即存储容量为$2^{10}*8 = 2^{13}$，1K*8位
  
    再如MAR = 16，MDR = 32即存储容量为$2^{16}*32 = 2^{21} = 2M位$，64K*32位
  - 字节数 ，如213b=1KB，221b=256KB
- 辅存容量
  
  - 80GB（1G = 1024 M = 210∗220=230）

# 第2章 计算机的发展及应用

## 2.1 计算机的发展史

- ENIAC，冯·诺依曼机器是在这个机器的研究过程中产出的
- 摩尔定律
  - 微芯片上集成的晶体管数目每三年翻两番
- 软件技术的兴起和发展
- 软件发展特点
  - 开发周期长
  - 制作成本昂贵
  - 检测软件产品质量的特殊性

## 2.2 计算机应用

- 科学计算和数据处理
- 工业控制和实时控制
- 网络技术
  - 电子商务
  - 网络教育
  - 敏捷制造
- 虚拟现实
- 办公自动化和管理信息系统
- CAD/CAM/CIMS
- 多媒体技术
- 人工智能

## 2.3 计算机的展望

- 计算机具有类似人脑的一些超级智能功能
  - 要求计算机的速度足够快
- 芯片集成度的提高受以下三方面限制
  - 芯片集成度物理极限的制约
  - 按几何级数数递增的制作成本
  - 芯片的功耗、散热、线延迟
- 替代传统的硅芯片
  - 光计算机
    - 利用光子取代电子进行运算和存储
  - DNA生物计算机
    - 通过控制DNA分子间的生化反应
  - 量子计算机
    - 利用原子所具有的量子特性

# 第3章 系统总线

## 3.1 总线的基本概念

- 什么是总线

  - 总线是连接各个部件的信息传输线，是各个部件共享的传输介质

- 总线上信息的传送

  - 串行：一位一位在总线上传送
  - 并行：多位同时，接收方也是多位
  - 串行长（多设备之间），并行短（集中在机箱内）

- 单总线结构计算机举例

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png)

  - 所有部件连接到一条总线上
  - 如果主存与I/O接口进行数据传输的话，主存和CPU之间就无法进行数据传输
  - 设备很多，系统总线会比较长

- 面向CPU的双总线结构

  - CPU和**I/O总线**相连，主存只和CPU通过**M总线**相连
  - CPU工作效率有所提高，但还是有缺点
  - 某一时刻各部件都要占用总线时，就会发生冲突

- 以存储器为中心的双总线结构

  - 在单总线的基础上，CPU和主存都连接**系统总线**的同时再通过**存储总线**相连
  - 既提高了传输效率，又减轻了系统总线的负担，还保留了I/O设备与存储器交换信息时不经过CPU的特点

## 3.2 总线的分类

#### 3.2.1 片内总线

- 芯片内部的总线
  - 比如：CPU芯片内部：
  - 寄存器与寄存器之间
  - 寄存器与算逻单元ALU之间

#### 3.2.2 系统总线

- 指CPU、主存、I/O设备**各大计算机部件之间的信息传输线**

- 按传输信息不同，分为三类：数据总线、地址总线和控制总线

  1. 数据总线：**双向**传输，其位数与机器字长、存储字长有关，一般为8位、16位或32位

  2. 地址总线：**单向**传输，其位数与存储地址、I/O地址有关

  3. 控制总线：有输入，有输出

     常见的控制信号：

     - 时钟：同步各种操作
     - 复位：初始化所有部件
     - 总线请求：某部件获得总线使用权
     - 总线允许：需要获得总线使用权的部件已获得控制权
     - 中断请求：某部件提出中断请求
     - 中断响应：中断请求已被接收
     - 存储器写：将数据总线上的数据写至存储器的指定地址单元内
     - 存储器读：将指定存储单元中的数据读到数据总线上
     - I/O读：从指定的I/O端口将数据读到数据总线上
     - I/O写：将数据总线上的数据输出到指定的I/O端口内
     - 传输响应：数据已1被接收，或已将数据送至数据总线上

#### 3.2.3 通信总线

- 用于**计算机系统之间**或**计算机系统与其他系统之间**的通信
- 传输方式分为两种：**串行通信**和**并行通信**

## 3.3 总线特性及性能指标

#### 3.3.1 总线特性

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%A9%E7%90%86%E5%AE%9E%E7%8E%B0.png)

1. 机械特性

   - **尺寸**、形状、**管脚数**及**排列顺序**

2. 电气特性

   - 信号的**传输方向**和有效**电平**范围

3. 功能特性

   - 每根传输线的

     功能

     - 地址总线用来指出地址码
     - 数据总线用来传递数据
     - 控制总线发出控制信号

4. 时间特性

   - 信号的**时序**关系，一般可用信号时序图来描述

#### 3.3.2 总线性能指标

1. 总线宽度：**数据线**的根数，用bit表示，如8位、16位、32位、64位（即8根、16根、32根、64根）

2. 总线带宽（标准传输率）：每秒传输的

   最大

   字节数，单位MBps

   - 例：总线工作频率为33MHz，总线宽度为32位（4 B），则总线带宽位33*(32÷8)=132 MBps

3. 时钟同步/异步：同步、不同步

4. 总线复用：地址线与数据线复用

5. 信号线数：地址线、数据线和控制线的总和

6. 总线控制方式：突发、自动、仲裁、逻辑、计数

7. 其他指标：负载能力、电源电压、总线宽度能否扩展

#### 3.3.3 总线标准

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86.png)

## 3.4 总线结构

#### 3.4.1 单总线结构

- 导致的问题是总线成为系统的瓶颈

#### 3.4.2 多总线结构

1. 双总线结构

   - **CPU**和**主存**及**通道**通过主存总线相连
   - I/O接口、设备通过I/O总线相连
   - I/O总线与主存总线之间通过**通道**相连
   - 通道（具有特殊功能的处理器，对I/O统一管理）有自己的指令系统，可以执行一些简单的指令
     - 通道的程序通常情况下，是由操作系统来编写的，并不是由人工来编写的

2. 三总线结构

   - 直接存储器访问
   - CPU是中心，如果有一些高速设备和内存之间信息交换，可以通过DMA总线与主存交换信息高速运行，但是低速设备依然要通过I/O总线

3. 三总线结构的另一种形式
   ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%BD%A2%E5%BC%8F.png)

   - CPU和主存之间交换的量最大
   - CPU运行时的指令和数据主要是从Cache中获取
   - 扩展总线解决了I/O设备的扩展问题，但影响外部设备工作速度

4. 四总线结构

   ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   - 桥电路扩展出了高速总线，低速设备通过扩展总线连接到扩展总线，使数据传输速度更高

## 3.5 总线控制

#### 3.5.1 总线判优控制

- 基本概念

  - 主设备：对总线有**控制权**
  - 从设备：**响应**从设备发来的总线命令
  - 总线判优控制：
    - 集中式
      - 链式查询
      - 计数器定时查询
      - 独立请求方式
    - 分布式

- 链式查询方式![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png)

  - 如果有一个设备占用了总线，就通过总线忙告诉其他总线
  - 顺序是BR->BG->BR
  - 每个设备的优先级和BG有直接关系，连接方式确定的

- 计数器定时查询方式

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png)

  - 总线控制部件里面有一个计数器，它的初值可以是0，也可以是其他值
  - 顺序是BR->接口0没有提出请求，计数器+1，看接口1有没有提出请求->通过设备地址线，项各设备发出一组地址信号，设备地址和计数器值匹配时，获得总线使用权->BS
  - 优先级可以通过设定计数器初值，循环进行
  - 设备地址线需要log2n条线

- 独立请求方式

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png)

  - 任何一个I/O接口都连接BR、BG
  - 总线控制部件中排队器
  - 顺序是多个BR同时发出总线请求->优先级排队

#### 3.5.2 总线通信控制

- 目的：解决通信双方**协调配合**问题

- 总线传输周期

  - 申请分配阶段：**主模块申请**，总线总裁决定
  - 寻址阶段：主模块向从模块**给出地址**和**命令**
  - 传数阶段：主模块和从模块**交换数据**
  - 结束阶段：主模块撤销有关信息，让出总线使用权

- 总线通信的四种方式

  - 同步通信：由**统一时标**控制数据传送
  - 异步通信：采用**应答方式**，没有公共时钟标准
  - 半通信同步：同步、异步结合
  - 分离式通信：充分**挖掘**系统**总线每个瞬间**的潜力

- 同步式数据输入

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E4%BC%A0%E8%BE%93.png)

  - 在T1时钟的上升沿，必须要给出地址信号
  - 在T2上升沿必须给出读命令信号
  - 在T3上升沿到达前，从设备必须要给出数据信号，通过数据总线来传输
  - 在T3时钟周期内，将数据线上的信息送到其内部寄存器中
  - 在T4上升沿1到达前，数据信号和控制信号撤销
  - 在T4结束的时候，地址信号也撤销了

  它的特点是：

  - 一定要有定宽定距的时钟来控制整个数据传输的过程
  - 要在给定的时间点上完成一些相应的操作

- 同步式数据输出

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E4%BC%A0%E8%BE%93.png)

  - 在T1上升沿给出地址信号
  - 在T1下降沿要给出数据
  - 在T2上升沿要给出写命令
  - 在T3时钟周期进行这些操作
  - 在T4上升沿，撤销数据和写命令
  - T4结束时，把地址信息也撤掉

- 同步通信优点：

  - 规定明确、统一，模块间的配合简单一致

- 同步通信缺点：

  - 主、从模块时间强制性同步
  - 必须按照最慢速度的部件来设计公共时钟

- 同步通信一般用于总线长度较短、各部件存取时间比较一致的场合

  - 因为在同步通信的总线系统中，总线的传输周期越短，数据线的位数越多，直接影响总线的数据传输率
  - 总线长度来讲,必须按距离最长的两个设备的传输延迟来设计公共时钟。但是总线长了势必降低传输频率，所以同步通信一般用于总线长度较短的场合

- 异步通信

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%BA%94%E7%AD%94%E6%96%B9%E5%BC%8F.png)

  - 不互锁：应用例子CPU向主存写信息，CPU要先给出地址信号、写命令以及写入数据，用此方式
  - 半互锁：多机系统
  - 全互锁：网络通信

- 半同步通信（同步、异步结合）

  - 同步：

    - **发送方**用系统**时钟前沿**发信息
    - **接收方**用系统**时钟后沿**判断、识别

  - 异步

    - 允许不同速度的模块和谐工作
    - 为了调整主从设备差异速度的差异，增加了一条“等待”响应信号**WAIT**

  - 以输入数据为例的半同步通信时序

    ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.png)

    - T1 主模块发地址
    - T2 主模块发命令
    - Tw 从设备数据还没准备好，**WAIT**为低电平，等待一个T
    - Tw **WAIT**为低电平，等待一个T
    - 。。。。。。
    - T3 从模块提供数据
    - T4 从模块撤销数据，主模块撤销命令

- 以上三种通信的共同点

  - 一个总线传输周期（以输入数据为例）
    - 从模块发地址、命令 **占用总线**
    - 从模块准备数据 **不占用总线**
    - 从模块向主模块发数据 **占用总线**

- 分离式通信

  - 充分挖掘系统总线每个瞬间的潜力
  - 一个总线传输周期
    - 子周期1:主模块申请占用总线，使用完后即放弃总线的使用权
    - 子周期2:从设备申请占用总线，将各种信息送至总线上
  - 特点：
    1. 各模块有权申请占用总线
    2. 采用同步通信，不等对方回答
    3. 各模块准备数据时，不占用总线
    4. 总线被占用时，无空闲

# 第4章 存储器

## 4.1 概述

#### 4.1.1 存储器分类

- 按存储介质分类

  1. 半导体存储器：双极型TTL、MOS （易失）
  2. 磁表面存储器：磁头、载磁体
  3. 磁芯存储器：硬磁材料、环状元件
  4. 光盘存储器：激光、磁光材料

- 按存取方式分类

  1. 随机存储器（可读可写）
  2. 只读存储器（只读）
  3. 串行访问存储器
     1. 顺序存取存储器（磁带）
     2. 直接存取存储器（磁盘）

- 按在计算机中的作用分类

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%AD%98%E5%82%A8%E5%99%A8%E6%8C%89%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB.png)

#### 4.1.2 存储器的层次结构

- 存储器3个主要性能指标：速度、容量、位价

- 层次结构主要体现在缓存-主存和主存-辅存这两个存储层次上

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E7%BC%93%E5%AD%98-%E4%B8%BB%E5%AD%98%E5%92%8C%E4%B8%BB%E5%AD%98-%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1.png)

  - 缓存-主存层次解决CPU和主存速度不匹配，使速度接近缓存，高于主存
  - 主存-辅存层次解决存储系统的容量问题（虚拟存储器）

## *4.2 主存储器

#### 4.2.1 概述

- 主存的基本组成

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png)

- 主存和CPU的联系

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E7%9A%84%E8%81%94%E7%B3%BB.png)

- 主存中存储单元地址的分配

  - 大端、小端方式
  - 设地址线24根，按**字节**寻址224=16MB
  - 若字长为16位，按字寻址8MW
  - 若字长为32位，按字寻址4MW

- 主存的技术指标

  - 存储容量：主存、存放二进制代码的总位数
  - 存储速度：
    - 存取时间：存储器的访问时间（读出时间、写入时间）
    - 存取周期：连续两次独立的存储器操作（读或写）所需的最小间隔时间（读周期、写周期）
  - 存储器的带宽：位/秒

#### 4.2.2 半导体存储芯片简介

- 基本结构
  - 地址线单向输入，数据线双向
  - 例如：地址线10根，数据线4根，则芯片容量=210∗4=4K
  - 又例如：地址线14根，数据线1根，则容量为16K
- 线选法：一根字选择线，直接选中一个存储单元的各位
- 重合法：所选单元由X、Y（行列地址）两个方向决定

#### 4.2.3 随机存取存储器（RAM）

- 静态RAM(SRAM)
- 动态RAM(DRAM)
  - 电容上保存的有电荷1，无电荷0
  - 动态RAM刷新
    - 与行地址有关，与列地址无关，每次刷新都刷新一行的数据
    - 有些存储单元长期得不到访问，不进行存储器的读/写操作，存储单元内的原信息将会慢慢消失，为此，必须采用定时刷新的方法
    - 集中刷新（存取周期为0.5µs）：规定一个刷新周期，此周期内停止读/写操作，这个周期又称访存死区
    - 分散刷新：每行存储单元的刷新分散到每个存取周期内完成
    - 异步刷新（结合分散刷新与集中刷新）：将刷新安排在指令译码阶段，不会出现”死区“
- 动态和静态比较
  - 存储原理：一个电容一个触发器
  - 集成度：动态要远高于静态，动态一个管，静态就要4～6个
  - 芯片引脚：静态多，动态是按照行列先后顺序输送
  - 功耗：动态小
  - 价格：静态高，比动态快8～16倍，价格也高8～16倍
  - 速度：静态快
  - 刷新：动态有刷新
  - 动态做主存，静态做Cache

#### 4.2.4 只读存储器（ROM）

- 掩模ROM（MROM）
  - 行列选择线交叉处有MOS管为“1”，无为“0”
- PROM（一次性编程）
  - 熔丝断为“0”，未断为“1”
  - 是一种破坏性编程
- EPROM（多次性编程）
  - N型沟道浮动栅MOS电路
    - D端加正电压，形成浮动栅，S和D不导通
    - D端不加正电压，S与D导通为“1”
  - 改写方法：紫外线照射
  - 价格便宜1，集成度高
- EEPROM（多次性编程）
  - 电可擦写：可局部擦写也可全部擦写
- Flash Memory（闪速型存储器）
  - 比EEPROM快，具备RAM功能

#### *4.2.5 存储器与CPU的连接

1. **存储器容量的扩展**

   1. 位扩展（增加存储字长）

      用2片 1Kx4位 存储芯片组成 1Kx8位 的存储器

      - 地址线连接方式完全相同
      - 数据线各占了按序的4位

   2. 字扩展（增加存储字的数量）

      用2片 1Kx8位 存储芯片组成 2Kx8位 的存储器

      - 数据线连接相同
      - 地址线一条用作片选信号，选择通过电平高低进行选择

   3. 字、位扩展

      用8片 1Kx4位 的芯片组成 4Kx8位 的存储器

      - 两个一组先构成8位的存储字长
      - 分为4组，通过两根地址线经过译码器得到4个片选信号

2. **存储器与CPU的连接**（P94例题）

   1. 地址线的连接
   2. 数据线的连接
   3. 读写命令线的连接
   4. 片选线的连接
   5. 合理选择存储芯片
   6. 其他：时序、负载
